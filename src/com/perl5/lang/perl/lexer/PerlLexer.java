/*
 * Copyright 2015 Alexandr Evstigneev
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* The following code was generated by JFlex 1.4.3 on 03.05.15 13:19 */

package com.perl5.lang.perl.lexer;


import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.psi.TokenType;
import com.intellij.psi.tree.IElementType;
import com.intellij.psi.tree.TokenSet;
import gnu.trove.THashMap;
import org.jetbrains.annotations.Nullable;

import java.io.IOException;
import java.util.Map;
import java.util.regex.Pattern;

public class PerlLexer extends PerlLexerGenerated
{
	public static final String STRING_UNDEF = "undef";
	public static final Pattern ASCII_IDENTIFIER_PATTERN = Pattern.compile("[_a-zA-Z][_\\w]*");
	public static final Pattern IDENTIFIER_PATTERN = Pattern.compile("[_\\p{L}][_\\p{L}\\d]*");
	public static final Pattern ASCII_BARE_STRING_PATTERN = Pattern.compile("[-+]*[_a-zA-Z][_\\w]*");
	// pattern for getting marker
	public static final Pattern HEREDOC_OPENER_PATTERN = Pattern.compile("<<(.+?)");
	public static final Pattern HEREDOC_OPENER_PATTERN_DQ = Pattern.compile("<<(\\s*)(\")(.*?)\"");
	public static final Pattern HEREDOC_OPENER_PATTERN_SQ = Pattern.compile("<<(\\s*)(\')(.*?)\'");
	public static final Pattern HEREDOC_OPENER_PATTERN_XQ = Pattern.compile("<<(\\s*)(`)(.*?)`");
	public static final Map<String, IElementType> RESERVED_TOKEN_TYPES = new THashMap<>();
	public static final Map<String, IElementType> CUSTOM_TOKEN_TYPES = new THashMap<>();
	// tokens that preceeds regexp opener or file <FH>
	public static TokenSet BARE_REGEX_PREFIX_TOKENSET = TokenSet.EMPTY;
	public static TokenSet RESERVED_TOKENSET;
	public static TokenSet CUSTOM_TOKENSET;

	public PerlLexer(@Nullable Project project)
	{
		super(null);
	}

	public static void initReservedTokensMap()
	{
		RESERVED_TOKEN_TYPES.clear();
		// reserved
	}

	public static void initReservedTokensSet()
	{
		RESERVED_TOKENSET = TokenSet.create(RESERVED_TOKEN_TYPES.values().toArray(new IElementType[RESERVED_TOKEN_TYPES.values().size()]));
		CUSTOM_TOKENSET = TokenSet.create(CUSTOM_TOKEN_TYPES.values().toArray(new IElementType[CUSTOM_TOKEN_TYPES.values().size()]));
	}

	@Override
	public int yystate()
	{
		return preparsedTokensList.isEmpty() &&
				!myFormatWaiting &&
				heredocQueue.isEmpty() &&
				myBracesStack.isEmpty() &&
				myBracketsStack.isEmpty() &&
				myParensStack.isEmpty()
				? super.yystate() : PREPARSED_ITEMS;
	}

	/**
	 * Lexers perlAdvance method. Parses some thing here, or just invoking generated flex parser
	 *
	 * @return next token type
	 */
	public IElementType perlAdvance() throws IOException
	{

		CharSequence buffer = getBuffer();
		int tokenStart = getTokenEnd();
		int bufferEnd = getBufferEnd();

		if (bufferEnd == 0 || tokenStart >= bufferEnd)
		{
			return super.perlAdvance();
		}
		else
		{
			int currentState = getRealLexicalState();
			char currentChar = buffer.charAt(tokenStart);

			// capture heredoc
			if (waitingHereDoc() && (tokenStart == 0 || currentChar == '\n'))
			{
				setNoSharpState();
				return captureHereDoc(false);
			}
			// capture format
			else if (myFormatWaiting && (tokenStart == 0 || buffer.charAt(tokenStart - 1) == '\n'))
			{
				setNoSharpState();
				IElementType tokenType = captureFormat();
				myFormatWaiting = false;
				if (tokenType != null)    // got something
				{
					return tokenType;
				}
			}
		}
		return super.perlAdvance();
	}

	/**
	 * Captures HereDoc document and returns appropriate token type
	 *
	 * @param afterEmptyCloser - this here-doc being captured after empty closer, e.g. sequentional <<"", <<""
	 * @return Heredoc token type
	 */
	public IElementType captureHereDoc(boolean afterEmptyCloser)
	{
		final PerlHeredocQueueElement heredocQueueElement = heredocQueue.remove(0);
		final CharSequence heredocMarker = heredocQueueElement.getMarker();

		IElementType tokenType = heredocQueueElement.getTargetElement();

		CharSequence buffer = getBuffer();
		int tokenStart = getTokenEnd();

		if (!afterEmptyCloser)
		{
			pushPreparsedToken(tokenStart++, tokenStart, TokenType.NEW_LINE_INDENT);
		}

		int bufferEnd = getBufferEnd();

		int currentPosition = tokenStart;
		int linePos = currentPosition;


		while (true)
		{
			while (linePos < bufferEnd && buffer.charAt(linePos) != '\n' && buffer.charAt(linePos) != '\r')
			{
				linePos++;
			}
			int lineContentsEnd = linePos;

			if (linePos < bufferEnd && buffer.charAt(linePos) == '\r')
			{
				linePos++;
			}
			if (linePos < bufferEnd && buffer.charAt(linePos) == '\n')
			{
				linePos++;
			}

			// reached the end of heredoc and got end marker

			if (heredocMarker.length() == 0 && lineContentsEnd == currentPosition && linePos > lineContentsEnd)
			{
				// non-empty heredoc and got the end
				if (currentPosition > tokenStart)
				{
					pushPreparsedToken(tokenStart, currentPosition, tokenType);
				}
				pushPreparsedToken(currentPosition, lineContentsEnd + 1, HEREDOC_END);

				if (!heredocQueue.isEmpty() && bufferEnd > lineContentsEnd + 1)
				{
					setTokenEnd(lineContentsEnd + 1);
					return captureHereDoc(true);
				}
				else
				{
					return getPreParsedToken();
				}
			}
			else if (StringUtil.equals(heredocMarker, buffer.subSequence(currentPosition, lineContentsEnd)))
			{
				// non-empty heredoc and got the end
				if (currentPosition > tokenStart)
				{
					pushPreparsedToken(tokenStart, currentPosition, tokenType);
				}
				pushPreparsedToken(currentPosition, lineContentsEnd, HEREDOC_END);
				return getPreParsedToken();
			}
			// reached the end of file
			else if (linePos == bufferEnd)
			{
				// non-empty heredoc and got the end of file
				if (linePos > tokenStart)
				{
					pushPreparsedToken(tokenStart, linePos, tokenType);
				}
				return getPreParsedToken();
			}
			currentPosition = linePos;
		}
	}

	/**
	 * Captures format; fixme refactor with captureHeredoc got common parts
	 *
	 * @return Heredoc token type
	 */
	public IElementType captureFormat()
	{
		CharSequence buffer = getBuffer();
		int tokenStart = getTokenEnd();
		setTokenStart(tokenStart);
		int bufferEnd = getBufferEnd();

		int currentPosition = tokenStart;
		int linePos = currentPosition;

		while (true)
		{
			while (linePos < bufferEnd && buffer.charAt(linePos) != '\n' && buffer.charAt(linePos) != '\r')
			{
				linePos++;
			}
			int lineContentsEnd = linePos;

			if (linePos < bufferEnd && buffer.charAt(linePos) == '\r')
			{
				linePos++;
			}
			if (linePos < bufferEnd && buffer.charAt(linePos) == '\n')
			{
				linePos++;
			}

			// reached the end of format and got end marker
			if (lineContentsEnd == currentPosition + 1 && buffer.charAt(currentPosition) == '.')
			{
				preparsedTokensList.clear();
				preparsedTokensList.add(new CustomToken(currentPosition, lineContentsEnd, FORMAT_TERMINATOR));

				// non-empty heredoc and got the end
				if (currentPosition > tokenStart)
				{
					setTokenStart(tokenStart);
					setTokenEnd(currentPosition);
					return FORMAT;
				}
				// empty format and got the end
				else
				{
					return getPreParsedToken();
				}
			}
			// reached the end of file
			else if (linePos == bufferEnd)
			{
				// non-empty format and got the end of file
				if (currentPosition > tokenStart)
				{
					setTokenStart(tokenStart);
					setTokenEnd(currentPosition);
					return FORMAT;
				}
				// empty heredoc and got the end of file
				else
				{
					return null;
				}
			}
			currentPosition = linePos;
		}
	}

	public void reset(CharSequence buf, int start, int end, int initialState)
	{
		super.reset(buf, start, end, initialState);
//		System.err.println(String.format("Lexer re-set to %d - %d, %d of %d", start, end, end - start, buf.length()));
	}


	/**
	 * Sets up regex parser
	 */
	public void processRegexOpener(IElementType tokenType)
	{
		regexCommand = tokenType;

		if (regexCommand == RESERVED_S)    // two sections s
		{
			sectionsNumber = 2;
		}
		else                        // one section qr m
		{
			sectionsNumber = 1;
		}

		pushState();
		yybegin(REGEX_OPENER);
	}


	/**
	 * Transliteration processors tr y
	 **/
	public void processTransOpener()
	{
		pushState();
		yybegin(TRANS_OPENER);
	}

	/**
	 * Quote-like string procesors
	 **/
	public void processQuoteLikeStringOpener(IElementType tokenType)
	{
		pushState();
		if (tokenType == RESERVED_Q)
		{
			yybegin(QUOTE_LIKE_OPENER_Q);
		}
		else if (tokenType == RESERVED_QQ)
		{
			yybegin(QUOTE_LIKE_OPENER_QQ);
		}
		else if (tokenType == RESERVED_QX)
		{
			yybegin(QUOTE_LIKE_OPENER_QX);
		}
		else if (tokenType == RESERVED_QW)
		{
			yybegin(QUOTE_LIKE_OPENER_QW);
		}
		else
		{
			throw new RuntimeException("Unable to switch state by token " + tokenType);
		}
	}

	public boolean waitingHereDoc()
	{
		return !heredocQueue.isEmpty();
	}

	/**
	 * Bareword parser, resolves built-ins and runs additional processings where it's necessary
	 *
	 * @return token type
	 */
	public IElementType getIdentifierToken()
	{
		String tokenText = yytext().toString();
		IElementType tokenType;

		if ((tokenType = RESERVED_TOKEN_TYPES.get(tokenText)) == null &&
				(tokenType = CUSTOM_TOKEN_TYPES.get(tokenText)) == null
				)
		{
			tokenType = IDENTIFIER;
		}

		yybegin(BARE_REGEX_PREFIX_TOKENSET.contains(tokenType) ? YYINITIAL : AFTER_IDENTIFIER);

		return tokenType;
	}

	@Override
	public void resetInternals()
	{
		super.resetInternals();
		heredocQueue.clear();
	}

	@Override
	public IElementType advance() throws IOException
	{
		boolean wasPreparsed = !preparsedTokensList.isEmpty();

		IElementType tokenType = super.advance();

		if (!wasPreparsed && preparsedTokensList.isEmpty())
		{
			if (tokenType == RESERVED_QW || tokenType == RESERVED_Q || tokenType == RESERVED_QQ || tokenType == RESERVED_QX)
			{
				processQuoteLikeStringOpener(tokenType);
			}
			else if (tokenType == RESERVED_S || tokenType == RESERVED_M || tokenType == RESERVED_QR)
			{
				processRegexOpener(tokenType);
			}
			else if (tokenType == RESERVED_TR || tokenType == RESERVED_Y)
			{
				processTransOpener();
			}
			else if (tokenType == RESERVED_FORMAT)
			{
				myFormatWaiting = true;
			}
		}

		return tokenType;
	}

}
