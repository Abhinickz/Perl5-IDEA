/*
 * Copyright 2015 Alexandr Evstigneev
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* The following code was generated by JFlex 1.4.3 on 03.05.15 13:19 */

package com.perl5.lang.perl.lexer;


import com.intellij.lexer.FlexLexer;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.psi.TokenType;
import com.intellij.psi.tree.IElementType;
import com.intellij.psi.tree.TokenSet;
import com.perl5.lang.embedded.lexer.EmbeddedPerlLexer;
import com.perl5.lang.perl.parser.PerlParserUtil;

import java.io.IOException;
import java.io.Reader;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class PerlLexer extends PerlLexerGenerated
{
	public static final String STRING_UNDEF = "undef";
	public static final Pattern ASCII_IDENTIFIER_PATTERN = Pattern.compile("[_a-zA-Z][_\\w]*");
	public static final Pattern IDENTIFIER_PATTERN = Pattern.compile("[_\\p{L}][_\\p{L}\\d]*");
	public static final Pattern ASCII_BARE_STRING_PATTERN = Pattern.compile("[-+]*[_a-zA-Z][_\\w]*");

	// pattern for getting marker
	public static final Pattern HEREDOC_OPENER_PATTERN = Pattern.compile("<<(.+?)");
	public static final Pattern HEREDOC_OPENER_PATTERN_DQ = Pattern.compile("<<(\\s*)(\")(.*?)\"");
	public static final Pattern HEREDOC_OPENER_PATTERN_SQ = Pattern.compile("<<(\\s*)(\')(.*?)\'");
	public static final Pattern HEREDOC_OPENER_PATTERN_XQ = Pattern.compile("<<(\\s*)(`)(.*?)`");

	public static final String TR_MODIFIERS = "cdsr";
	public static final TokenSet ALLOWED_WHILE_WAITING_SUB_ATTRIBUTE = TokenSet.create(
			TokenType.NEW_LINE_INDENT
			, TokenType.WHITE_SPACE
			, COMMENT_BLOCK
			, COMMENT_LINE
			, POD

			// for prototype/signature
			, LEFT_PAREN
			, RIGHT_PAREN

			// var name in signature
			, IDENTIFIER

			// namespace allowed in sub name
			, PACKAGE
			, PACKAGE_CORE_IDENTIFIER
			, PACKAGE_IDENTIFIER
			, PACKAGE_PRAGMA_CONSTANT
			, PACKAGE_PRAGMA_VARS

			// comma separated vars and colon starts attribute
			, COLON
			, OPERATOR_COMMA
			, OPERATOR_COMMA_ARROW

			// prototype sybmols
			, SIGIL_SCALAR
			, SIGIL_ARRAY
			, SIGIL_HASH
			, OPERATOR_MOD
			, OPERATOR_MUL
			, OPERATOR_BITWISE_AND
			, LEFT_BRACKET
			, RIGHT_BRACKET
			, OPERATOR_REFERENCE
			, OPERATOR_PLUS
			, SEMICOLON
	);
	// tokens allowed to be between my/our/state and attributes :
	public static final TokenSet ALLOWED_WHILE_WAITING_VAR_ATTRIBUTE = TokenSet.create(
			TokenType.NEW_LINE_INDENT
			, TokenType.WHITE_SPACE
			, COMMENT_BLOCK
			, COMMENT_LINE
			, POD

			// for list declaration
			, LEFT_PAREN
			, RIGHT_PAREN

			// var name
			, IDENTIFIER

			// namespace allowed in our
			, PACKAGE
			, PACKAGE_CORE_IDENTIFIER
			, PACKAGE_IDENTIFIER
			, PACKAGE_PRAGMA_CONSTANT
			, PACKAGE_PRAGMA_VARS

			// comma separated vars and colon starts attribute
			, COLON
			, OPERATOR_COMMA
			, OPERATOR_COMMA_ARROW

			// variables sigils
			, SIGIL_SCALAR
			, SIGIL_ARRAY
			, SIGIL_HASH
			, OPERATOR_MOD

			// variable name may be braced fixme this wont' work for now, see #504
//			, LEFT_BRACE
//			, RIGHT_BRACE
	);
	// tokens allowed to be in attribute
	public static final TokenSet ALLOWED_IN_ATTRIBUTE = TokenSet.create(
			TokenType.NEW_LINE_INDENT
			, TokenType.WHITE_SPACE
			, COMMENT_BLOCK
			, COMMENT_LINE
			, POD

			, IDENTIFIER
			, QUOTE_SINGLE_OPEN
			, QUOTE_SINGLE_CLOSE
			, COLON
			, STRING_CONTENT
	);
	// http://perldoc.perl.org/perldata.html#Identifier-parsing
	// pre-variable name tokens
	public static final TokenSet SIGILS_TOKENS = TokenSet.create(
			SIGIL_ARRAY,
			SIGIL_SCALAR,
			SIGIL_SCALAR_INDEX,
			OPERATOR_BITWISE_AND,    // code sigil
			OPERATOR_MOD,    // hash sigil
			OPERATOR_MUL    // glob sigil
	);
	// we should not check bareword for reserved tokens if following was before
	public static final TokenSet PRE_PACKAGE_TOKENS = TokenSet.create(
			RESERVED_USE,
			RESERVED_NO,
			RESERVED_PACKAGE,
			RESERVED_MY,
			RESERVED_OUR,
			RESERVED_STATE,
			RESERVED_LOCAL
	);
	// prefixes, disables identifier interpretation attempt
	public static final TokenSet IDENTIFIER_NEGATION_PREFIX = TokenSet.orSet(
			PRE_PACKAGE_TOKENS,
			TokenSet.create(
					RESERVED_SUB,            // sub eval
					OPERATOR_DEREFERENCE    // ->identifier
			)
	);
	// operators tokens (except commas)
	public static final TokenSet OPERATORS_TOKENSET = TokenSet.create(
			OPERATOR_CMP_NUMERIC,
			OPERATOR_LT_NUMERIC,
			OPERATOR_GT_NUMERIC,

			OPERATOR_CMP_STR,
			OPERATOR_LE_STR,
			OPERATOR_GE_STR,
			OPERATOR_EQ_STR,
			OPERATOR_NE_STR,
			OPERATOR_LT_STR,
			OPERATOR_GT_STR,

			OPERATOR_HELLIP,
			OPERATOR_FLIP_FLOP,
			OPERATOR_CONCAT,

			OPERATOR_PLUS_PLUS,
			OPERATOR_MINUS_MINUS,
			OPERATOR_POW,

			OPERATOR_RE,
			OPERATOR_NOT_RE,

//			OPERATOR_HEREDOC, // this is an artificial operator, not the real one
			OPERATOR_SHIFT_LEFT,
			OPERATOR_SHIFT_RIGHT,

			OPERATOR_AND,
			OPERATOR_OR,
			OPERATOR_OR_DEFINED,
			OPERATOR_NOT,

			OPERATOR_ASSIGN,

			QUESTION,
			COLON,

			OPERATOR_REFERENCE,

			OPERATOR_DIV,
			OPERATOR_MUL,
			OPERATOR_MOD,
			OPERATOR_PLUS,
			OPERATOR_MINUS,

			OPERATOR_BITWISE_NOT,
			OPERATOR_BITWISE_AND,
			OPERATOR_BITWISE_OR,
			OPERATOR_BITWISE_XOR,

			OPERATOR_AND_LP,
			OPERATOR_OR_LP,
			OPERATOR_XOR_LP,
			OPERATOR_NOT_LP,

			OPERATOR_COMMA,
			OPERATOR_COMMA_ARROW,

			OPERATOR_DEREFERENCE,

			OPERATOR_X,
			OPERATOR_FILETEST,

			// syntax operators
			OPERATOR_POW_ASSIGN,
			OPERATOR_PLUS_ASSIGN,
			OPERATOR_MINUS_ASSIGN,
			OPERATOR_MUL_ASSIGN,
			OPERATOR_DIV_ASSIGN,
			OPERATOR_MOD_ASSIGN,
			OPERATOR_CONCAT_ASSIGN,
			OPERATOR_X_ASSIGN,
			OPERATOR_BITWISE_AND_ASSIGN,
			OPERATOR_BITWISE_OR_ASSIGN,
			OPERATOR_BITWISE_XOR_ASSIGN,
			OPERATOR_SHIFT_LEFT_ASSIGN,
			OPERATOR_SHIFT_RIGHT_ASSIGN,
			OPERATOR_AND_ASSIGN,
			OPERATOR_OR_ASSIGN,
			OPERATOR_OR_DEFINED_ASSIGN,

			OPERATOR_GE_NUMERIC,
			OPERATOR_LE_NUMERIC,
			OPERATOR_EQ_NUMERIC,
			OPERATOR_NE_NUMERIC,
			OPERATOR_SMARTMATCH
	);
	public static final Map<String, IElementType> RESERVED_TOKEN_TYPES = new HashMap<String, IElementType>();
	public static final Map<String, IElementType> CUSTOM_TOKEN_TYPES = new HashMap<String, IElementType>();
	public static final TokenSet QUOTE_LIKE_STRING_OPENER_TOKENSET = TokenSet.create(
			RESERVED_QW,
			RESERVED_Q,
			RESERVED_QQ,
			RESERVED_QX
	);
	public static final TokenSet QUOTE_LIKE_REGEX_OPENER_TOKENSET = TokenSet.create(
			RESERVED_S,
			RESERVED_M,
			RESERVED_QR
	);
	public static final TokenSet QUOTE_LIKE_TRANSLATE_OPENER_TOKENSET = TokenSet.create(
			RESERVED_TR,
			RESERVED_Y
	);
	public static final TokenSet QUOTE_LIKE_OPENER_TOKENSET = TokenSet.orSet(
			QUOTE_LIKE_STRING_OPENER_TOKENSET,
			QUOTE_LIKE_REGEX_OPENER_TOKENSET,
			QUOTE_LIKE_TRANSLATE_OPENER_TOKENSET
	);
	// tokens that preceeds regexp opener or file <FH>
	public static TokenSet BARE_REGEX_PREFIX_TOKENSET =
			TokenSet.andNot(
					TokenSet.orSet(
							OPERATORS_TOKENSET
							, TokenSet.create(
									SEMICOLON,
									COLON,
									LEFT_PAREN,
									LEFT_BRACE,
									LEFT_BRACKET
							)),
					TokenSet.create(
							OPERATOR_PLUS_PLUS,
							OPERATOR_MINUS_MINUS
					)
			);
	public static TokenSet RESERVED_TOKENSET;
	public static TokenSet CUSTOM_TOKENSET;
	public static TokenSet LABEL_TOKENSET;

	/**
	 * HEREDOC proceccing section
	 */

	// last captured heredoc marker
	protected final Stack<PerlHeredocQueueElement> heredocQueue = new Stack<PerlHeredocQueueElement>();
	/**
	 * Quote-like, transliteration and regexps common part
	 */
	public boolean allowSharpQuote = true;
	public boolean isEscaped = false;
	public int sectionsNumber = 0;    // number of sections one or two

	protected PerlLexerAdapter evalPerlLexer;
	protected PerlStringLexer myStringLexer;
	protected PerlQStringLexer myQStringLexer;
	protected PerlQQStringLexer myQQStringLexer;
	protected PerlQXStringLexer myQXStringLexer;
	protected PerlQWStringLexer myQWStringLexer;
	/**
	 * Regex processor qr{} m{} s{}{}
	 **/
	protected IElementType regexCommand = null;
	Project myProject;
	private boolean myFormatWaiting = false;

	public PerlLexer(Project project)
	{
		super((Reader) null);
		myProject = project;
	}

	public static void initReservedTokensMap()
	{
		RESERVED_TOKEN_TYPES.clear();
		// reserved
	}

	public static void initReservedTokensSet()
	{
		RESERVED_TOKENSET = TokenSet.create(RESERVED_TOKEN_TYPES.values().toArray(new IElementType[RESERVED_TOKEN_TYPES.values().size()]));
		CUSTOM_TOKENSET = TokenSet.create(CUSTOM_TOKEN_TYPES.values().toArray(new IElementType[CUSTOM_TOKEN_TYPES.values().size()]));

		LABEL_TOKENSET = TokenSet.andNot(
				TokenSet.orSet(
						RESERVED_TOKENSET,
						CUSTOM_TOKENSET,
						PerlParserUtil.CONVERTABLE_TOKENS
				),
				TokenSet.orSet(
						QUOTE_LIKE_OPENER_TOKENSET,
						TokenSet.create(RESERVED_SUB)
				)
		);
	}

	/**
	 * Lex current token with specific lexer
	 *
	 * @param tokenLexer lexer to use
	 * @return list of custom tokens
	 */
	public static List<CustomToken> processLexer(FlexLexer tokenLexer)
	{
		ArrayList<CustomToken> result = new ArrayList<CustomToken>();

		try
		{
			IElementType tokenType;
			while ((tokenType = tokenLexer.advance()) != null)
			{
				result.add(new CustomToken(tokenLexer.getTokenStart(), tokenLexer.getTokenEnd(), tokenType));
			}
		}
		catch (IOException e)
		{
			e.printStackTrace();
		}

		return result;
	}

	public List<CustomToken> lexCurrentToken(FlexLexer tokenLexer)
	{
		tokenLexer.reset(getBuffer(), getTokenStart(), getTokenEnd(), 0);
		return processLexer(tokenLexer);
	}

	@Override
	public int yystate()
	{
		return preparsedTokensList.isEmpty() && !myFormatWaiting && heredocQueue.isEmpty() ? super.yystate() : LEX_PREPARSED_ITEMS;
	}


	/**
	 * Lexers perlAdvance method. Parses some thing here, or just invoking generated flex parser
	 *
	 * @return next token type
	 * @throws IOException
	 */
	public IElementType perlAdvance() throws IOException
	{

		CharSequence buffer = getBuffer();
		int tokenStart = getTokenEnd();
		int bufferEnd = getBufferEnd();

		if (bufferEnd == 0 || tokenStart >= bufferEnd)
		{
			return super.perlAdvance();
		}
		else
		{
			int currentState = getRealLexicalState();
			char currentChar = buffer.charAt(tokenStart);

			// capture heredoc
			if (waitingHereDoc() && (tokenStart == 0 || currentChar == '\n'))
			{
				return captureHereDoc(false);
			}
			// capture format
			else if (myFormatWaiting && (tokenStart == 0 || buffer.charAt(tokenStart - 1) == '\n'))
			{
				IElementType tokenType = captureFormat();
				myFormatWaiting = false;
				if (tokenType != null)    // got something
				{
					return tokenType;
				}
			}
			else if (isOpeningQuoteFor(currentState, currentChar, LEX_QUOTE_LIKE_OPENER_Q, LEX_QUOTE_LIKE_OPENER_QQ, LEX_QUOTE_LIKE_OPENER_QX, LEX_QUOTE_LIKE_OPENER_QW))
			{
				return captureString();
			}
			else if (isOpeningQuoteFor(currentState, currentChar, LEX_REGEX_OPENER))
			{
				return parseRegex(tokenStart);
			}
			else if (isOpeningQuoteFor(currentState, currentChar, LEX_TRANS_OPENER))
			{
				return parseTr();
			}
			// capture line comment
			else if (currentChar == '#')
			{
				// comment may end on newline or ?>
				int currentPosition = tokenStart;
				setTokenStart(tokenStart);

				while (currentPosition < bufferEnd && !isLineCommentEnd(currentPosition))
				{
					currentPosition++;
				}

				setTokenEnd(currentPosition);
				// catching annotations #@
				if (tokenStart + 1 < bufferEnd && buffer.charAt(tokenStart + 1) == '@')
				{
					return COMMENT_ANNOTATION;
				}

				return COMMENT_LINE;
			}
		}
		return super.perlAdvance();
	}

	public boolean isOpeningQuoteFor(int currentState, char currentChar, int... states)
	{
		for (int state : states)
		{
			if (state == currentState)
			{
				return !Character.isWhitespace(currentChar)
						&& (currentChar != '#' || allowSharpQuote);
			}
		}

		return false;
	}

	/**
	 * Captures string token from current position according to the current lexical state
	 *
	 * @return string token
	 */
	public IElementType captureString()
	{
		CharSequence buffer = getBuffer();
		int currentPosition = getTokenEnd();
		setTokenStart(currentPosition);
		int bufferEnd = getBufferEnd();

		char openQuote = buffer.charAt(currentPosition);
		char closeQuote = RegexBlock.getQuoteCloseChar(openQuote);
		boolean quotesDiffer = openQuote != closeQuote;

		boolean isEscaped = false;
		int quotesDepth = 0;    // for using with different quotes

		currentPosition++;

		while (currentPosition < bufferEnd)
		{
			char currentChar = buffer.charAt(currentPosition);

			if (!isEscaped && quotesDepth == 0 && currentChar == closeQuote)
			{
				break;
			}

			if (!isEscaped && quotesDiffer)
			{
				if (currentChar == openQuote)
				{
					quotesDepth++;
				}
				else if (currentChar == closeQuote)
				{
					quotesDepth--;
				}
			}

			isEscaped = !isEscaped && currentChar == '\\';

			currentPosition++;
		}

		if (currentPosition < bufferEnd)    // got close quote
		{
			currentPosition++;
		}

		setTokenEnd(currentPosition);

//		System.err.println("Captured string " + yytext() );

		// following block is for lazy parsing of strings, seems works slower
//		IElementType tokenType = getStringTokentType();
//		popState();
//		return tokenType;

		PerlStringLexer stringLexer = getStringLexer();
		popState();
		preparsedTokensList.addAll(lexCurrentToken(stringLexer));
		return getPreParsedToken();
	}


	/**
	 * Lazy getter for StringLexer
	 *
	 * @return string lexer
	 */
	@Deprecated
	protected PerlStringLexer getBareStringLexer()
	{
		if (myStringLexer == null)
		{
			myStringLexer = new PerlStringLexer(myProject);
		}

		return myStringLexer;
	}

	/**
	 * Lazy getter for QStringLexer
	 *
	 * @return string lexer
	 */
	protected PerlQStringLexer getQStringLexer()
	{
		if (myQStringLexer == null)
		{
			myQStringLexer = new PerlQStringLexer();
		}

		return myQStringLexer;
	}


	/**
	 * Lazy getter for QStringLexer
	 *
	 * @return string lexer
	 */
	protected PerlQQStringLexer getQQStringLexer()
	{
		if (myQQStringLexer == null)
		{
			myQQStringLexer = new PerlQQStringLexer(myProject);
		}

		return myQQStringLexer;
	}

	/**
	 * Lazy getter for QStringLexer
	 *
	 * @return string lexer
	 */
	protected PerlQXStringLexer getQXStringLexer()
	{
		if (myQXStringLexer == null)
		{
			myQXStringLexer = new PerlQXStringLexer(myProject);
		}

		return myQXStringLexer;
	}

	/**
	 * Lazy getter for QStringLexer
	 *
	 * @return string lexer
	 */
	protected PerlQWStringLexer getQWStringLexer()
	{
		if (myQWStringLexer == null)
		{
			myQWStringLexer = new PerlQWStringLexer();
		}

		return myQWStringLexer;
	}


	/**
	 * Checking if comment is ended. Implemented for overriding in {@link EmbeddedPerlLexer#isLineCommentEnd(int)} }
	 *
	 * @param currentPosition current position to check
	 * @return checking result
	 */
	public boolean isLineCommentEnd(int currentPosition)
	{
		return getBuffer().charAt(currentPosition) == '\n';
	}


	public IElementType parseHeredocOpenerBackref()
	{
		CharSequence openToken = yytext();
		int tokenStart = getTokenStart();
		pushPreparsedToken(tokenStart + 2, tokenStart + 3, OPERATOR_REFERENCE);
		pushPreparsedToken(tokenStart + 3, tokenStart + openToken.length(), STRING_CONTENT);
		heredocQueue.push(new PerlHeredocQueueElement(HEREDOC, openToken.subSequence(3, openToken.length()).toString()));
		setTokenEnd(tokenStart + 2);
		return OPERATOR_HEREDOC;
	}

	/**
	 * Processing captured heredoc opener. Stores marker and switches to proper lexical state
	 *
	 * @return PERL_OPERATOR  for << operator
	 */
	public IElementType parseHeredocOpener()
	{
		CharSequence openToken = yytext();
		Matcher m;
		IElementType targetElement = HEREDOC_QQ;

		if (StringUtil.endsWithChar(openToken, '"'))
		{
			m = HEREDOC_OPENER_PATTERN_DQ.matcher(openToken);
		}
		else if (StringUtil.endsWithChar(openToken, '\''))
		{
			m = HEREDOC_OPENER_PATTERN_SQ.matcher(openToken);
			targetElement = HEREDOC;
		}
		else if (StringUtil.endsWithChar(openToken, '`'))
		{
			m = HEREDOC_OPENER_PATTERN_XQ.matcher(openToken);
			targetElement = HEREDOC_QX;
		}
		else
		{
			m = HEREDOC_OPENER_PATTERN.matcher(openToken);
		}

		Character nextCharacter = getNextSignificantCharacter();
		yypushback(openToken.length() - 2);

		if (m.matches())
		{
			preparsedTokensList.clear();
			int currentPosition = getNextTokenStart();

			if (m.groupCount() > 1)    // quoted heredoc
			{
				String heredocMarker = m.group(3);
				heredocQueue.push(new PerlHeredocQueueElement(targetElement, heredocMarker));

				int elementLength = m.group(1).length();
				if (elementLength > 0)    // got spaces
				{
					pushPreparsedToken(currentPosition, currentPosition + elementLength, TokenType.WHITE_SPACE);
				}

				currentPosition += elementLength;

				pushPreparsedToken(currentPosition, currentPosition + 1, getOpenQuoteTokenType(m.group(2).charAt(0)));
				currentPosition++;

				if (heredocMarker.length() > 0)
				{
					pushPreparsedToken(currentPosition, currentPosition + heredocMarker.length(), STRING_IDENTIFIER);
					currentPosition += heredocMarker.length();
				}

				pushPreparsedToken(currentPosition, currentPosition + 1, getCloseQuoteTokenType(m.group(2).charAt(0)));
			}
			else if (m.group(1).matches("\\d+"))    // check if it's numeric shift
			{
				return OPERATOR_SHIFT_LEFT;
			}
			else    // bareword heredoc
			{
				if (nextCharacter != null && nextCharacter.equals('('))    // it's a sub
				{
					return OPERATOR_SHIFT_LEFT;
				}

				String heredocMarker = m.group(1);
				heredocQueue.push(new PerlHeredocQueueElement(targetElement, heredocMarker));
				preparsedTokensList.add(new CustomToken(currentPosition, currentPosition + heredocMarker.length(), STRING_IDENTIFIER));
			}
		}
		else
		{
			throw new RuntimeException("Unable to parse HEREDOC opener " + openToken);
		}

		return OPERATOR_HEREDOC;
	}

	/**
	 * Captures HereDoc document and returns appropriate token type
	 *
	 * @param afterEmptyCloser - this here-doc being captured after empty closer, e.g. sequentional <<"", <<""
	 * @return Heredoc token type
	 */
	public IElementType captureHereDoc(boolean afterEmptyCloser)
	{
		final PerlHeredocQueueElement heredocQueueElement = heredocQueue.remove(0);
		final String heredocMarker = heredocQueueElement.getMarker();

		IElementType tokenType = heredocQueueElement.getTargetElement();

		CharSequence buffer = getBuffer();
		int tokenStart = getTokenEnd();

		if (!afterEmptyCloser)
		{
			pushPreparsedToken(tokenStart++, tokenStart, TokenType.NEW_LINE_INDENT);
		}

		int bufferEnd = getBufferEnd();

		int currentPosition = tokenStart;
		int linePos = currentPosition;


		while (true)
		{
			while (linePos < bufferEnd && buffer.charAt(linePos) != '\n' && buffer.charAt(linePos) != '\r')
			{
				linePos++;
			}
			int lineContentsEnd = linePos;

			if (linePos < bufferEnd && buffer.charAt(linePos) == '\r')
			{
				linePos++;
			}
			if (linePos < bufferEnd && buffer.charAt(linePos) == '\n')
			{
				linePos++;
			}

			// reached the end of heredoc and got end marker

			if (heredocMarker.isEmpty() && lineContentsEnd == currentPosition && linePos > lineContentsEnd)
			{
				// non-empty heredoc and got the end
				if (currentPosition > tokenStart)
				{
					pushPreparsedToken(tokenStart, currentPosition, tokenType);
				}
				pushPreparsedToken(currentPosition, lineContentsEnd + 1, HEREDOC_END);

				if (!heredocQueue.isEmpty() && bufferEnd > lineContentsEnd + 1)
				{
					setTokenEnd(lineContentsEnd + 1);
					return captureHereDoc(true);
				}
				else
				{
					return getPreParsedToken();
				}
			}
			else if (StringUtil.equals(heredocMarker, buffer.subSequence(currentPosition, lineContentsEnd)))
			{
				// non-empty heredoc and got the end
				if (currentPosition > tokenStart)
				{
					pushPreparsedToken(tokenStart, currentPosition, tokenType);
				}
				pushPreparsedToken(currentPosition, lineContentsEnd, HEREDOC_END);
				return getPreParsedToken();
			}
			// reached the end of file
			else if (linePos == bufferEnd)
			{
				// non-empty heredoc and got the end of file
				if (linePos > tokenStart)
				{
					pushPreparsedToken(tokenStart, linePos, tokenType);
				}
				return getPreParsedToken();
			}
			currentPosition = linePos;
		}
	}

	/**
	 * Captures format; fixme refactor with captureHeredoc got common parts
	 *
	 * @return Heredoc token type
	 */
	public IElementType captureFormat()
	{
		CharSequence buffer = getBuffer();
		int tokenStart = getTokenEnd();
		setTokenStart(tokenStart);
		int bufferEnd = getBufferEnd();

		int currentPosition = tokenStart;
		int linePos = currentPosition;

		while (true)
		{
			while (linePos < bufferEnd && buffer.charAt(linePos) != '\n' && buffer.charAt(linePos) != '\r')
			{
				linePos++;
			}
			int lineContentsEnd = linePos;

			if (linePos < bufferEnd && buffer.charAt(linePos) == '\r')
			{
				linePos++;
			}
			if (linePos < bufferEnd && buffer.charAt(linePos) == '\n')
			{
				linePos++;
			}

			// reached the end of format and got end marker
			if (lineContentsEnd == currentPosition + 1 && buffer.charAt(currentPosition) == '.')
			{
				preparsedTokensList.clear();
				preparsedTokensList.add(new CustomToken(currentPosition, lineContentsEnd, FORMAT_TERMINATOR));

				// non-empty heredoc and got the end
				if (currentPosition > tokenStart)
				{
					setTokenStart(tokenStart);
					setTokenEnd(currentPosition);
					return FORMAT;
				}
				// empty format and got the end
				else
				{
					return getPreParsedToken();
				}
			}
			// reached the end of file
			else if (linePos == bufferEnd)
			{
				// non-empty format and got the end of file
				if (currentPosition > tokenStart)
				{
					setTokenStart(tokenStart);
					setTokenEnd(currentPosition);
					return FORMAT;
				}
				// empty heredoc and got the end of file
				else
				{
					return null;
				}
			}
			currentPosition = linePos;
		}
	}

	public void reset(CharSequence buf, int start, int end, int initialState)
	{
		super.reset(buf, start, end, initialState);
//		System.err.println(String.format("Lexer re-set to %d - %d, %d of %d", start, end, end - start, buf.length()));
	}


	// guess if this is a OPERATOR_DIV or regex opener
	public IElementType startRegexp()
	{
		allowSharpQuote = true;
		isEscaped = false;
		regexCommand = RESERVED_M;
		sectionsNumber = 1;
		pushState();
		return parseRegex(getTokenStart());
	}

	/**
	 * Sets up regex parser
	 */
	public void processRegexOpener(IElementType tokenType)
	{
		allowSharpQuote = true;
		isEscaped = false;
		regexCommand = tokenType;

		if (regexCommand == RESERVED_S)    // two sections s
		{
			sectionsNumber = 2;
		}
		else                        // one section qr m
		{
			sectionsNumber = 1;
		}

		pushState();
		yybegin(LEX_REGEX_OPENER);
	}

	/**
	 * Parsing tr/y content
	 *
	 * @return first token
	 */
	public IElementType parseTr()
	{
		popState();
		yybegin(LEX_OPERATOR);
		CharSequence buffer = getBuffer();
		int currentOffset = getTokenEnd();
		int bufferEnd = getBufferEnd();

		// search block
		char openQuote = buffer.charAt(currentOffset);
		char closeQuote = RegexBlock.getQuoteCloseChar(openQuote);
		boolean quotesDiffer = openQuote != closeQuote;
		pushPreparsedToken(currentOffset++, currentOffset, REGEX_QUOTE_OPEN);

		currentOffset = parseTrBlockContent(currentOffset, openQuote, closeQuote);

		// close quote
		if (currentOffset < bufferEnd)
		{
			pushPreparsedToken(currentOffset++, currentOffset, quotesDiffer ? REGEX_QUOTE_CLOSE : REGEX_QUOTE);
		}

		// between blocks
		if (quotesDiffer)
		{
			currentOffset = lexWhiteSpacesAndComments(currentOffset, preparsedTokensList);
		}

		// second block
		if (currentOffset < bufferEnd)
		{
			if (quotesDiffer)
			{
				openQuote = buffer.charAt(currentOffset);
				closeQuote = RegexBlock.getQuoteCloseChar(openQuote);
				pushPreparsedToken(currentOffset++, currentOffset, REGEX_QUOTE_OPEN);
			}

			currentOffset = parseTrBlockContent(currentOffset, openQuote, closeQuote);
		}

		// close quote
		if (currentOffset < bufferEnd)
		{
			pushPreparsedToken(currentOffset++, currentOffset, REGEX_QUOTE_CLOSE);
		}


		// trans modifiers
		if (currentOffset < bufferEnd)
		{
			int blockStart = currentOffset;
			while (currentOffset < bufferEnd && StringUtil.containsChar(TR_MODIFIERS, buffer.charAt(currentOffset)))
			{
				currentOffset++;
			}

			if (blockStart < currentOffset)
			{
				pushPreparsedToken(blockStart, currentOffset, REGEX_MODIFIER);
			}
		}

		return getPreParsedToken();
	}

	/**
	 * Parsing tr block content till close quote
	 *
	 * @param currentOffset start offset
	 * @param closeQuote    close quote character
	 * @return next offset
	 */
	int parseTrBlockContent(int currentOffset, char openQuote, char closeQuote)
	{
		int blockStartOffset = currentOffset;
		CharSequence buffer = getBuffer();
		int bufferEnd = getBufferEnd();
		boolean isEscaped = false;
		boolean isQuoteDiffers = openQuote != closeQuote;
		int quotesLevel = 0;

		while (currentOffset < bufferEnd)
		{
			char currentChar = buffer.charAt(currentOffset);

			if (!isEscaped && quotesLevel == 0 && currentChar == closeQuote)
			{
				if (currentOffset > blockStartOffset)
				{
					pushPreparsedToken(blockStartOffset, currentOffset, STRING_CONTENT);
				}
				break;
			}
			if (isQuoteDiffers && !isEscaped)
			{
				if (currentChar == openQuote)
				{
					quotesLevel++;
				}
				else if (currentChar == closeQuote)
				{
					quotesLevel--;
				}
			}

			isEscaped = (currentChar == '\\' && !isEscaped);
			currentOffset++;
		}

		return currentOffset;
	}

	/**
	 * Lexing empty spaces and comments between regex/tr blocks and adding tokens to the target list
	 *
	 * @param currentOffset start offset
	 * @param targetList    target list for CustomTokens
	 * @return new offset
	 */
	protected int lexWhiteSpacesAndComments(int currentOffset, List<CustomToken> targetList)
	{
		CharSequence buffer = getBuffer();
		int bufferEnd = getBufferEnd();
		while (currentOffset < bufferEnd)
		{
			char currentChar = buffer.charAt(currentOffset);

			if (currentChar == '\n')
			{
				targetList.add(getCustomToken(currentOffset++, currentOffset, TokenType.NEW_LINE_INDENT));
			}
			else if (Character.isWhitespace(currentChar))    // white spaces
			{
				int whiteSpaceStart = currentOffset;
				while (currentOffset < bufferEnd && Character.isWhitespace(currentChar = buffer.charAt(currentOffset)) && currentChar != '\n')
				{
					currentOffset++;
				}
				targetList.add(getCustomToken(whiteSpaceStart, currentOffset, TokenType.WHITE_SPACE));
			}
			else if (currentChar == '#')    // line comment
			{
				int commentStart = currentOffset;
				while (currentOffset < bufferEnd && buffer.charAt(currentOffset) != '\n')
				{
					currentOffset++;
				}
				targetList.add(getCustomToken(commentStart, currentOffset, COMMENT_LINE));
			}
			else
			{
				break;
			}
		}

		return currentOffset;
	}


	/**
	 * Parses regexp from the current position (opening delimiter) and preserves tokens in preparsedTokensList
	 * REGEX_MODIFIERS = [msixpodualgcer]
	 *
	 * @return opening delimiter type
	 */
	public IElementType parseRegex(int tokenStart)
	{
		popState();
		yybegin(LEX_OPERATOR);
		CharSequence buffer = getBuffer();
		int bufferEnd = getBufferEnd();

		char openQuote = buffer.charAt(tokenStart);
		pushPreparsedToken(tokenStart++, tokenStart, REGEX_QUOTE_OPEN);

		// find block 1
		RegexBlock firstBlock = RegexBlock.parseBlock(buffer, tokenStart, bufferEnd, openQuote, false);

		if (firstBlock == null)
		{
			return getPreParsedToken();
		}

		int currentOffset = firstBlock.getEndOffset();

		// find block 2
		List<CustomToken> betweenBlocks = new ArrayList<CustomToken>();
		RegexBlock secondBLock = null;
		CustomToken secondBlockOpener = null;

		if (sectionsNumber == 2 && currentOffset < bufferEnd)
		{
			if (firstBlock.hasSameQuotes())
			{
				secondBLock = RegexBlock.parseBlock(buffer, currentOffset, bufferEnd, firstBlock.getOpeningQuote(), true);
			}
			else
			{
				currentOffset = lexWhiteSpacesAndComments(currentOffset, betweenBlocks);

				if (currentOffset < bufferEnd)
				{
					// read block
					secondBlockOpener = new CustomToken(currentOffset, currentOffset + 1, REGEX_QUOTE_OPEN);
					secondBLock = RegexBlock.parseBlock(buffer, currentOffset + 1, bufferEnd, buffer.charAt(currentOffset), true);
				}
			}

			if (secondBLock == null)
			{
				return getPreParsedToken();
			}

			currentOffset = secondBLock.getEndOffset();
		}

		// check modifiers for x
		boolean isExtended = false;
		boolean isEvaluated = false;
		assert regexCommand != null;
		List<Character> allowedModifiers = RegexBlock.ALLOWED_MODIFIERS.get(regexCommand);
		int modifiersEnd = currentOffset;
		ArrayList<CustomToken> modifierTokens = new ArrayList<CustomToken>();

		while (modifiersEnd < bufferEnd)
		{
			if (!allowedModifiers.contains(buffer.charAt(modifiersEnd)))    // unknown modifier
			{
				break;
			}
			else if (buffer.charAt(modifiersEnd) == 'x')    // mark as extended
			{
				if (preparsedTokensList.getFirst().getTokenType() == REGEX_QUOTE_OPEN)
				{
					preparsedTokensList.getFirst().setTokenType(REGEX_QUOTE_OPEN_X);
				}

				isExtended = true;
			}
			else if (buffer.charAt(modifiersEnd) == 'e')    // mark as evaluated
			{
				isEvaluated = true;
				if (secondBlockOpener != null)
				{
					secondBlockOpener.setTokenType(REGEX_QUOTE_OPEN_E);
				}
			}

			modifierTokens.add(new CustomToken(modifiersEnd, modifiersEnd + 1, REGEX_MODIFIER));

			modifiersEnd++;
		}

		// parse block 1
		preparsedTokensList.addAll(firstBlock.tokenize(getBareStringLexer(), isExtended, false));

		if (secondBLock != null)
		{
			// parse spaces
			preparsedTokensList.addAll(betweenBlocks);

			if (secondBlockOpener != null)
			{
				preparsedTokensList.add(secondBlockOpener);
			}
			else if (isEvaluated)
			{
				preparsedTokensList.getLast().setTokenType(REGEX_QUOTE_E);
			}
			else
			{
				preparsedTokensList.getLast().setTokenType(REGEX_QUOTE);
			}


			// parse block 2
			if (isEvaluated)
			{
				if (evalPerlLexer == null)
				{
					evalPerlLexer = new PerlLexerAdapter(myProject);
				}
				preparsedTokensList.addAll(secondBLock.parseEval(evalPerlLexer));
			}
			else
			{
				preparsedTokensList.addAll(secondBLock.tokenize(getBareStringLexer(), false, true));
			}
		}

		// parse modifiers
		preparsedTokensList.addAll(modifierTokens);

		return getPreParsedToken();
	}

	/**
	 * Transliteration processors tr y
	 **/
	public void processTransOpener()
	{
		allowSharpQuote = true;
		pushState();
		yybegin(LEX_TRANS_OPENER);
	}

	/**
	 * Quote-like string procesors
	 **/
	public void processQuoteLikeStringOpener(IElementType tokenType)
	{
		allowSharpQuote = true;
		isEscaped = false;
		pushState();
		if (tokenType == RESERVED_Q)
		{
			yybegin(LEX_QUOTE_LIKE_OPENER_Q);
		}
		else if (tokenType == RESERVED_QQ)
		{
			yybegin(LEX_QUOTE_LIKE_OPENER_QQ);
		}
		else if (tokenType == RESERVED_QX)
		{
			yybegin(LEX_QUOTE_LIKE_OPENER_QX);
		}
		else if (tokenType == RESERVED_QW)
		{
			yybegin(LEX_QUOTE_LIKE_OPENER_QW);
		}
		else
		{
			throw new RuntimeException("Unable to switch state by token " + tokenType);
		}
	}

	public IElementType getOpenQuoteTokenType(char quoteCharacter)
	{
		if (quoteCharacter == '"')
		{
			return QUOTE_DOUBLE_OPEN;
		}
		else if (quoteCharacter == '`')
		{
			return QUOTE_TICK_OPEN;
		}
		else if (quoteCharacter == '\'')
		{
			return QUOTE_SINGLE_OPEN;
		}
		else
		{
			throw new RuntimeException("Unknown open quote type " + quoteCharacter);
		}
	}

	public IElementType getCloseQuoteTokenType(char quoteCharacter)
	{
		if (quoteCharacter == '"')
		{
			return QUOTE_DOUBLE_CLOSE;
		}
		else if (quoteCharacter == '`')
		{
			return QUOTE_TICK_CLOSE;
		}
		else if (quoteCharacter == '\'')
		{
			return QUOTE_SINGLE_CLOSE;
		}
		else
		{
			throw new RuntimeException("Unknown close quote type " + quoteCharacter);
		}
	}


	public PerlStringLexer getStringLexer()
	{
		int currentState = getRealLexicalState();
		if (currentState == LEX_QUOTE_LIKE_OPENER_Q)
		{
			return getQStringLexer();
		}
		if (currentState == LEX_QUOTE_LIKE_OPENER_QQ)
		{
			return getQQStringLexer();
		}
		if (currentState == LEX_QUOTE_LIKE_OPENER_QX)
		{
			return getQXStringLexer();
		}
		if (currentState == LEX_QUOTE_LIKE_OPENER_QW)
		{
			return getQStringLexer();
		}
//		return getQWStringLexer();

		throw new RuntimeException("Unknown lexical state for string token " + currentState);
	}

	public boolean waitingHereDoc()
	{
		return !heredocQueue.isEmpty();
	}

	/**
	 * Bareword parser, resolves built-ins and runs additional processings where it's necessary
	 *
	 * @return token type
	 */
	public IElementType getIdentifierToken()
	{
		String tokenText = yytext().toString();
		IElementType tokenType;
		PerlTokenHistory tokenHistory = getTokenHistory();
		IElementType lastSignificantTokenType = tokenHistory.getLastSignificantTokenType();

		boolean isSigilBehind = SIGILS_TOKENS.contains(tokenHistory.getLastTokenType());

		if (!IDENTIFIER_NEGATION_PREFIX.contains(lastSignificantTokenType)
				&& !isSigilBehind    // print $$ if smth
				)
		{

			if ((tokenType = RESERVED_TOKEN_TYPES.get(tokenText)) != null)
			{
				return tokenType;
			}
		}

		if (!isSigilBehind && (tokenType = CUSTOM_TOKEN_TYPES.get(tokenText)) != null)
		{
			return tokenType;
		}

		return IDENTIFIER;
	}

	// checks if ahead is comma, semi, close brace
	private boolean isListElementEndAhead()
	{
		int nextPosition = getNextSignificantCharacterPosition(getTokenEnd());
		if (nextPosition > -1)
		{
			CharSequence buffer = getBuffer();
			char nextChar = buffer.charAt(nextPosition);
			if (
					nextChar == ','
							|| nextChar == ';'
							|| nextChar == ')'
							|| nextChar == '='
							&& nextPosition + 1 < getBufferEnd()
							&& buffer.charAt(nextPosition + 1) == '>'
					)
			{
				return true;
			}
		}
		return false;
	}

	// checks if ahead is =>
	private boolean isCommaArrowAhead()
	{
		int nextPosition = getNextSignificantCharacterPosition(getTokenEnd());
		if (nextPosition > -1)
		{
			CharSequence buffer = getBuffer();
			if (
					buffer.charAt(nextPosition) == '='
							&& nextPosition + 1 < getBufferEnd()
							&& buffer.charAt(nextPosition + 1) == '>'
					)
			{
				return true;
			}
		}
		return false;
	}


	@Override
	public void resetInternals()
	{
		super.resetInternals();
		heredocQueue.clear();
	}

	@Override
	public IElementType advance() throws IOException
	{
		boolean wasPreparsed = !preparsedTokensList.isEmpty();

		IElementType tokenType = super.advance();

		if (!wasPreparsed && preparsedTokensList.isEmpty())
		{

			if (tokenType == TokenType.NEW_LINE_INDENT || tokenType == TokenType.WHITE_SPACE)
			{
				allowSharpQuote = false;
			}
			else if (tokenType == RESERVED_QW || tokenType == RESERVED_Q || tokenType == RESERVED_QQ || tokenType == RESERVED_QX)
			{
				processQuoteLikeStringOpener(tokenType);
			}
			else if (tokenType == RESERVED_S || tokenType == RESERVED_M || tokenType == RESERVED_QR)
			{
				processRegexOpener(tokenType);
			}
			else if (tokenType == RESERVED_TR || tokenType == RESERVED_Y)
			{
				processTransOpener();
			}
			else if (tokenType == RESERVED_FORMAT)
			{
				myFormatWaiting = true;
			}
		}

		return tokenType;
	}

}
