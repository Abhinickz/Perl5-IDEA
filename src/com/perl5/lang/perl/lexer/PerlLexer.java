/*
 * Copyright 2015 Alexandr Evstigneev
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* The following code was generated by JFlex 1.4.3 on 03.05.15 13:19 */

package com.perl5.lang.perl.lexer;


import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.psi.TokenType;
import com.intellij.psi.tree.IElementType;
import com.intellij.psi.tree.TokenSet;
import com.perl5.lang.embedded.lexer.EmbeddedPerlLexer;
import com.perl5.lang.perl.PerlParserDefinition;
import com.perl5.lang.perl.parser.PerlParserUtil;
import com.perl5.lang.perl.util.PerlSubUtil;

import java.io.IOException;
import java.io.Reader;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class PerlLexer extends PerlLexerGenerated
{
	public static final String STRING_DATA = "__DATA__";
	public static final int STRING_DATA_LENGTH = STRING_DATA.length();
	public static final String STRING_END = "__END__";
	public static final int STRING_END_LENGTH = STRING_END.length();

	// pattern for getting marker
	public static final Pattern markerPattern = Pattern.compile("<<(.+?)");
	public static final Pattern markerPatternDQ = Pattern.compile("<<(\\s*)(\")(.+?)\"");
	public static final Pattern markerPatternSQ = Pattern.compile("<<(\\s*)(\')(.+?)\'");
	public static final Pattern markerPatternXQ = Pattern.compile("<<(\\s*)(`)(.+?)`");
	public static final Pattern versionIdentifierPattern = Pattern.compile("^(v[\\d_]+)");
	// http://perldoc.perl.org/perldata.html#Identifier-parsing
	// pre-variable name tokens
	public static final TokenSet SIGILS_TOKENS = TokenSet.create(
			SIGIL_ARRAY,
			SIGIL_SCALAR,
			SIGIL_SCALAR_INDEX,
			OPERATOR_BITWISE_AND,    // code sigil
			OPERATOR_MOD,    // hash sigil
			OPERATOR_MUL    // glob sigil
	);
	// we should not check bareword for reserved tokens if following was before
	public static final TokenSet PRE_PACKAGE_TOKENS = TokenSet.create(
			RESERVED_USE,
			RESERVED_NO,
			RESERVED_PACKAGE,
			RESERVED_MY,
			RESERVED_OUR,
			RESERVED_STATE,
			RESERVED_LOCAL
	);
	// prefixes, disables identifier interpretation attempt
	public static final TokenSet IDENTIFIER_NEGATION_PREFIX = TokenSet.orSet(
			PRE_PACKAGE_TOKENS,
			TokenSet.create(
					RESERVED_SUB,            // sub eval
					OPERATOR_DEREFERENCE    // ->identifier
			)
	);
	// operators tokens (except commas)
	public static final TokenSet OPERATORS_TOKENSET = TokenSet.create(
			OPERATOR_CMP_NUMERIC,
			OPERATOR_LT_NUMERIC,
			OPERATOR_GT_NUMERIC,

			OPERATOR_CMP_STR,
			OPERATOR_LE_STR,
			OPERATOR_GE_STR,
			OPERATOR_EQ_STR,
			OPERATOR_NE_STR,
			OPERATOR_LT_STR,
			OPERATOR_GT_STR,

			OPERATOR_HELLIP,
			OPERATOR_FLIP_FLOP,
			OPERATOR_CONCAT,

			OPERATOR_PLUS_PLUS,
			OPERATOR_MINUS_MINUS,
			OPERATOR_POW,

			OPERATOR_RE,
			OPERATOR_NOT_RE,

			OPERATOR_HEREDOC,
			OPERATOR_SHIFT_LEFT,
			OPERATOR_SHIFT_RIGHT,

			OPERATOR_AND,
			OPERATOR_OR,
			OPERATOR_OR_DEFINED,
			OPERATOR_NOT,

			OPERATOR_ASSIGN,

			QUESTION,
			COLON,

			OPERATOR_REFERENCE,

			OPERATOR_DIV,
			OPERATOR_MUL,
			OPERATOR_MOD,
			OPERATOR_PLUS,
			OPERATOR_MINUS,

			OPERATOR_BITWISE_NOT,
			OPERATOR_BITWISE_AND,
			OPERATOR_BITWISE_OR,
			OPERATOR_BITWISE_XOR,

			OPERATOR_AND_LP,
			OPERATOR_OR_LP,
			OPERATOR_XOR_LP,
			OPERATOR_NOT_LP,

			OPERATOR_COMMA,
			OPERATOR_COMMA_ARROW,

			OPERATOR_DEREFERENCE,

			OPERATOR_X,
			OPERATOR_FILETEST
	);
	// tokens which may preceeds .123 and . is a concat
	public static final TokenSet CONCAT_OPERATOR_PREFIX = TokenSet.create(
			IDENTIFIER,
			RIGHT_BRACE,
			RIGHT_PAREN,
			RIGHT_BRACKET,
			PACKAGE_IDENTIFIER,
			QUOTE_SINGLE_CLOSE,
			QUOTE_DOUBLE_CLOSE,
			QUOTE_TICK_CLOSE
	);
	// tokens that preceeds regexp opener
	public static final TokenSet REGEXP_PREFIX = TokenSet.create(
			SEMICOLON,
			COLON,
			LEFT_PAREN,
			LEFT_BRACE,
			LEFT_BRACKET
//			SUB	// fixme this works with argumentless subs, not all of them
	);
	public static final HashSet<String> REGEXP_PREFIX_SUBS = new HashSet<String>(Arrays.asList(
			"split",
			"return",
			"grep"
	));
	public static final HashSet<IElementType> RESERVED_TOKENSET = new HashSet<IElementType>();
	public static final HashMap<String, IElementType> PRAGMA_TOKENS_MAP = new HashMap<String, IElementType>();
	public static final HashMap<String, IElementType> reservedTokenTypes = new HashMap<String, IElementType>();
	public static final HashMap<String, IElementType> namedOperators = new HashMap<String, IElementType>();
	public static final HashMap<String, IElementType> blockNames = new HashMap<String, IElementType>();
	public static final HashMap<String, IElementType> tagNames = new HashMap<String, IElementType>();
	static final HashSet<String> PACKAGE_EXCEPTIONS = new HashSet<String>(Arrays.asList(
			"eq",
			"ne",
			"gt",
			"lt",
			"ge",
			"le",

			"qw",
			"qr",
			"qx",
			"qq",
			"tr",
			"m",
			"q",
			"s",
			"y"
	));
	public static Pattern annotationPattern = Pattern.compile("^(\\w+)(?:(\\s+)(.+)?)?$");
	public static Pattern annotationPatternPackage = Pattern.compile("^(\\w+(?:::\\w+)*)(.*)$");

	static
	{
		PRAGMA_TOKENS_MAP.put("constant", PACKAGE_PRAGMA_CONSTANT);
		PRAGMA_TOKENS_MAP.put("vars", PACKAGE_PRAGMA_VARS);
	}

	static
	{
		// named operators
		namedOperators.put("x", OPERATOR_X);

		namedOperators.put("not", OPERATOR_NOT_LP);
		namedOperators.put("and", OPERATOR_AND_LP);
		namedOperators.put("or", OPERATOR_OR_LP);
		namedOperators.put("xor", OPERATOR_XOR_LP);

		namedOperators.put("lt", OPERATOR_LT_STR);
		namedOperators.put("gt", OPERATOR_GT_STR);
		namedOperators.put("le", OPERATOR_LE_STR);
		namedOperators.put("ge", OPERATOR_GE_STR);
		namedOperators.put("eq", OPERATOR_EQ_STR);
		namedOperators.put("ne", OPERATOR_NE_STR);
		namedOperators.put("cmp", OPERATOR_CMP_STR);

		// block names
		blockNames.put("BEGIN", BLOCK_NAME);
		blockNames.put("UNITCHECK", BLOCK_NAME);
		blockNames.put("CHECK", BLOCK_NAME);
		blockNames.put("INIT", BLOCK_NAME);
		blockNames.put("END", BLOCK_NAME);

		// these added for core packages, not blocks, just subs
		blockNames.put("AUTOLOAD", BLOCK_NAME);
		blockNames.put("DESTROY", BLOCK_NAME);

		// tags
		tagNames.put("__FILE__", TAG);
		tagNames.put("__LINE__", TAG);
		tagNames.put("__PACKAGE__", TAG);
		tagNames.put("__SUB__", TAG);

		// reserved
		reservedTokenTypes.put("if", RESERVED_IF);
		reservedTokenTypes.put("unless", RESERVED_UNLESS);
		reservedTokenTypes.put("elsif", RESERVED_ELSIF);
		reservedTokenTypes.put("else", RESERVED_ELSE);
		reservedTokenTypes.put("given", RESERVED_GIVEN);
		reservedTokenTypes.put("when", RESERVED_WHEN);
		reservedTokenTypes.put("default", RESERVED_DEFAULT);
		reservedTokenTypes.put("while", RESERVED_WHILE);
		reservedTokenTypes.put("until", RESERVED_UNTIL);
		reservedTokenTypes.put("for", RESERVED_FOR);
		reservedTokenTypes.put("foreach", RESERVED_FOREACH);
		reservedTokenTypes.put("continue", RESERVED_CONTINUE);

		reservedTokenTypes.put("format", RESERVED_FORMAT);
		reservedTokenTypes.put("sub", RESERVED_SUB);
		reservedTokenTypes.put("package", RESERVED_PACKAGE);
		reservedTokenTypes.put("use", RESERVED_USE);
		reservedTokenTypes.put("no", RESERVED_NO);
		reservedTokenTypes.put("require", RESERVED_REQUIRE);

		reservedTokenTypes.put("undef", RESERVED_UNDEF);

		reservedTokenTypes.put("print", RESERVED_PRINT);
		reservedTokenTypes.put("printf", RESERVED_PRINTF);
		reservedTokenTypes.put("say", RESERVED_SAY);

		reservedTokenTypes.put("grep", RESERVED_GREP);
		reservedTokenTypes.put("map", RESERVED_MAP);
		reservedTokenTypes.put("sort", RESERVED_SORT);

		reservedTokenTypes.put("qw", RESERVED_QW);

		reservedTokenTypes.put("qq", RESERVED_QQ);
		reservedTokenTypes.put("q", RESERVED_Q);
		reservedTokenTypes.put("qx", RESERVED_QX);

		reservedTokenTypes.put("tr", RESERVED_TR);
		reservedTokenTypes.put("y", RESERVED_Y);

		reservedTokenTypes.put("s", RESERVED_S);
		reservedTokenTypes.put("qr", RESERVED_QR);
		reservedTokenTypes.put("m", RESERVED_M);

		reservedTokenTypes.put("my", RESERVED_MY);
		reservedTokenTypes.put("our", RESERVED_OUR);
		reservedTokenTypes.put("state", RESERVED_STATE);
		reservedTokenTypes.put("local", RESERVED_LOCAL);

		reservedTokenTypes.put("do", RESERVED_DO);
		reservedTokenTypes.put("eval", RESERVED_EVAL);

		reservedTokenTypes.put("goto", RESERVED_GOTO);
		reservedTokenTypes.put("redo", RESERVED_REDO);
		reservedTokenTypes.put("next", RESERVED_NEXT);
		reservedTokenTypes.put("last", RESERVED_LAST);

		RESERVED_TOKENSET.addAll(reservedTokenTypes.values());
	}

	/**
	 * HEREDOC proceccing section
	 */

	// last captured heredoc marker
	public String heredocMarker;
	/**
	 * Quote-like, transliteration and regexps common part
	 */
	public boolean allowSharpQuote = true;
	public char charOpener;
	public char charCloser;
	public int stringContentStart;
	public boolean isEscaped = false;
	public int sectionsNumber = 0;    // number of sections one or two
	public int currentSectionNumber = 0; // current section
	protected PerlLexerAdapter evalPerlLexer;
	protected PerlStringLexer myStringLexer;
	Project myProject;
	/**
	 * Regex processor qr{} m{} s{}{}
	 **/
	String regexCommand = null;

	public PerlLexer(Project project)
	{
		super((Reader) null);
		myProject = project;
	}

	public static List<CustomToken> lexString(PerlStringLexer initedStringLexer)
	{
		ArrayList<CustomToken> result = new ArrayList<CustomToken>();

		try
		{
			IElementType tokenType;
			while ((tokenType = initedStringLexer.advance()) != null)
				result.add(new CustomToken(initedStringLexer.getTokenStart(), initedStringLexer.getTokenEnd(), tokenType));
		} catch (IOException e)
		{
			e.printStackTrace();
		}

		return result;
	}

	// fixme to make this work you must remove final in PerlParserGenerated manually.
	@Override
	public int yystate()
	{
		if (preparsedTokensList.size() > 0)
			return LEX_PREPARSED_ITEMS;
		return super.yystate();
	}

	/**
	 * Lexers perlAdvance method. Parses some thing here, or just invoking generated flex parser
	 *
	 * @return next token type
	 * @throws IOException
	 */
	public IElementType perlAdvance() throws IOException
	{

		CharSequence buffer = getBuffer();
		int tokenStart = getTokenEnd();
		int bufferEnd = buffer.length();

		if (bufferEnd == 0 || tokenStart >= bufferEnd)
			return super.perlAdvance();
		else
		{
			int currentState = yystate();
			char currentChar = buffer.charAt(tokenStart);

			// capture heredoc
			if (waitingHereDoc() && (tokenStart == 0 || currentChar == '\n'))
			{
				IElementType tokenType = captureHereDoc();
				if (tokenType != null)    // got something
					return tokenType;
			}
			// capture format
			else if (currentState == LEX_FORMAT_WAITING && (tokenStart == 0 || buffer.charAt(tokenStart - 1) == '\n'))
			{
				IElementType tokenType = captureFormat();
				if (tokenType != null)    // got something
					return tokenType;
			} else if (currentState == LEX_QUOTE_LIKE_WORDS)
				return captureQuoteLikeWords();
			else if (
					(currentState == LEX_QUOTE_LIKE_OPENER || currentState == LEX_QUOTE_LIKE_OPENER_QQ || currentState == LEX_QUOTE_LIKE_OPENER_QX)
							&& !Character.isWhitespace(currentChar)
							&& (currentChar != '#' || allowSharpQuote)
					)
				return captureString();
			else if (currentState == LEX_TRANS_CLOSER)
				return processTransCloser();
			else if (currentChar == '\''
					&& currentState != LEX_TRANS_OPENER    // fixme this would be fixed after tr capture refactoring
					&& currentState != LEX_TRANS_CHARS
					&& currentState != LEX_REGEX_OPENER
					)
				return captureString(LEX_QUOTE_LIKE_OPENER);
			else if (currentChar == '"'
					&& currentState != LEX_TRANS_OPENER    // fixme this would be fixed after tr capture refactoring
					&& currentState != LEX_TRANS_CHARS
					&& currentState != LEX_REGEX_OPENER
					)
				return captureString(LEX_QUOTE_LIKE_OPENER_QQ);
			else if (currentChar == '`'
					&& currentState != LEX_TRANS_OPENER    // fixme  this would be fixed after tr capture refactoring
					&& currentState != LEX_TRANS_CHARS
					&& currentState != LEX_REGEX_OPENER
					)
				return captureString(LEX_QUOTE_LIKE_OPENER_QX);
				// capture __DATA__ __END__
				// capture pod
			else if (currentChar == '=' && (tokenStart == 0 || buffer.charAt(tokenStart - 1) == '\n'))
				return capturePodBlock();
				// capture qw content from qw();
			else if (((tokenStart < bufferEnd - STRING_DATA_LENGTH) && StringUtil.equals(buffer.subSequence(tokenStart, tokenStart + STRING_DATA_LENGTH), STRING_DATA))
					|| ((tokenStart < bufferEnd - STRING_END_LENGTH) && StringUtil.equals(buffer.subSequence(tokenStart, tokenStart + STRING_END_LENGTH), STRING_END))
					)
			{
				setTokenStart(tokenStart);
				setTokenEnd(bufferEnd);
				return COMMENT_BLOCK;
			}
			// capture line comment
			else if (
					currentChar == '#'
							// fixme these should be in tokenset
							&& (currentState != LEX_QUOTE_LIKE_LIST_OPENER || !allowSharpQuote)
							&& (
							currentState != LEX_QUOTE_LIKE_OPENER
									&& currentState != LEX_QUOTE_LIKE_OPENER_QQ
									&& currentState != LEX_QUOTE_LIKE_OPENER_QX
									|| !allowSharpQuote)
							&& (currentState != LEX_TRANS_OPENER || !allowSharpQuote)
							&& (currentState != LEX_TRANS_CHARS)
							&& (currentState != LEX_REGEX_OPENER)
					)
			{
				// comment may end on newline or ?>
				int currentPosition = tokenStart;
				setTokenStart(tokenStart);

				while (currentPosition < bufferEnd && !isLineCommentEnd(currentPosition))
					currentPosition++;

				// catching annotations #@
				if (tokenStart + 1 < bufferEnd && buffer.charAt(tokenStart + 1) == '@')
				{
					if (currentPosition > tokenStart + 2)
						parseAnnotation(buffer.subSequence(tokenStart + 2, currentPosition), tokenStart + 2);

					setTokenEnd(tokenStart + 2);
					return ANNOTATION_PREFIX;
				}

				setTokenEnd(currentPosition);
				return COMMENT_LINE;
			}

		}

		return super.perlAdvance();
	}


	/**
	 * Changes current lexical state and than captures string
	 *
	 * @return string token
	 */
	public IElementType captureString(int newState) throws IOException
	{
		if (SIGILS_TOKENS.contains(lastTokenType)    // this is not a beginning of a string, but variable name
				|| (
				lastSignificantTokenType == LEFT_BRACE
						&& SIGILS_TOKENS.contains(lastUnbraceTokenType)
						&& getNextNonSpaceCharacter() == '}'
		)
				)
			return super.perlAdvance();

		pushState();
		yybegin(newState);
		return captureString();
	}


	/**
	 * Captures string token from current position according to the current lexical state
	 *
	 * @return string token
	 */
	public IElementType captureString()
	{
		CharSequence buffer = getBuffer();
		int currentPosition = getTokenEnd();
		setTokenStart(currentPosition);
		int bufferEnd = getBufferEnd();

		char openQuote = buffer.charAt(currentPosition);
		char closeQuote = RegexBlock.getQuoteCloseChar(openQuote);
		boolean quotesDiffer = openQuote != closeQuote;

		boolean isEscaped = false;
		int quotesDepth = 0;    // for using with different quotes

		currentPosition++;

		while (currentPosition < bufferEnd)
		{
			char currentChar = buffer.charAt(currentPosition);

			if (!isEscaped && quotesDepth == 0 && currentChar == closeQuote)
				break;

			if (!isEscaped && quotesDiffer)
				if (currentChar == openQuote)
					quotesDepth++;
				else if (currentChar == closeQuote)
					quotesDepth--;

			isEscaped = !isEscaped && currentChar == '\\';

			currentPosition++;
		}

		if (currentPosition < bufferEnd)    // got close quote
			currentPosition++;

		setTokenEnd(currentPosition);

//		System.err.println("Captured string " + yytext() );

		IElementType stringTokentType = getStringTokentType();
		popState();
		return stringTokentType;
	}


	public IElementType captureQuoteLikeWords()
	{
		popState();
		CharSequence buffer = getBuffer();
		int tokenStart = getTokenEnd();
		int bufferEnd = buffer.length();
		int currentPosition = tokenStart;

		boolean isEscaped = false;
		boolean quotesDiffer = charOpener != charCloser;
		int quotesDepth = 0;    // for using with different quotes

		preparsedTokensList.clear();

		int currentWordStart = currentPosition;
		IElementType currentWordType = TokenType.WHITE_SPACE;

		while (currentPosition < bufferEnd)
		{
			char currentChar = buffer.charAt(currentPosition);

			// qw close quote
			if (!isEscaped && quotesDepth == 0 && currentChar == charCloser)
			{
				if (currentWordStart < currentPosition)
					preparsedTokensList.add(new CustomToken(currentWordStart, currentPosition, currentWordType));

				currentWordStart = currentPosition;
				currentPosition++;
				currentWordType = QUOTE_SINGLE_CLOSE;
				break;
			} else if (currentChar == '\n' || !isEscaped && Character.isSpaceChar(currentChar))    // atm no difference between space and \n tokens; \n unescapable
			{
				if (currentWordType != TokenType.WHITE_SPACE && currentWordStart < currentPosition) // word before it
				{
					preparsedTokensList.add(new CustomToken(currentWordStart, currentPosition, currentWordType));
					currentWordStart = currentPosition;
				}
				currentWordType = TokenType.WHITE_SPACE;
			} else    // non-space char
			{
				if (currentWordType != STRING_CONTENT && currentWordStart < currentPosition) // space before it
				{
					preparsedTokensList.add(new CustomToken(currentWordStart, currentPosition, currentWordType));
					currentWordStart = currentPosition;
				}
				currentWordType = STRING_CONTENT;

				// nested () check
				if (!isEscaped && quotesDiffer)
				{
					if (currentChar == charOpener)
						quotesDepth++;
					else if (currentChar == charCloser)
						quotesDepth--;
				}
			}

			isEscaped = !isEscaped && currentChar == '\\';
			currentPosition++;
		}

		if (currentWordStart < currentPosition)
			preparsedTokensList.add(new CustomToken(currentWordStart, currentPosition, currentWordType));

		assert preparsedTokensList.size() > 0;
		return getPreParsedToken();
	}

	protected PerlStringLexer getStringLexer()
	{
		if (myStringLexer == null)
			myStringLexer = new PerlStringLexer();


		return myStringLexer;
	}

	/**
	 * Checks that version is a really version, not a variable name
	 * fixme how about sub v123123 ?
	 *
	 * @return token type
	 */
	@Override
	public IElementType parseVersion()
	{
		if (SIGILS_TOKENS.contains(lastTokenType)
				|| isBraced() && SIGILS_TOKENS.contains(lastUnbraceTokenType)
				)
		{
			CharSequence tokenText = yytext();
			Matcher m = versionIdentifierPattern.matcher(tokenText);
			if (m.find())
			{
				if (m.group(1).length() < tokenText.length())
					yypushback(tokenText.length() - m.group(1).length());
				return IDENTIFIER;
			}

		}
		return NUMBER_VERSION;
	}

	/**
	 * Parses number, handling some specific cases
	 *
	 * @return token type
	 */
	@Override
	public IElementType parseNumber()
	{
		String tokenText = yytext().toString();
//		System.err.println("For "  + tokenText + "Last significant token is " + lastSignificantTokenType);
		if (StringUtil.startsWithChar(tokenText, '.') && CONCAT_OPERATOR_PREFIX.contains(lastSignificantTokenType)) // It's a $var.123; where . is a concat
		{
			yypushback(tokenText.length() - 1);
			return OPERATOR_CONCAT;
		} else if (tokenText.endsWith("."))
		{
			if (lastUnbraceTokenType == SIGIL_SCALAR) // $1.$something
			{
				yypushback(1);
				return IDENTIFIER;
			}
			Character nextCharacter = getNextCharacter();
			if (nextCharacter != null && nextCharacter.equals('.'))    // it's a 1..10
				yypushback(1);
		}
		return NUMBER;
	}

	/**
	 * Parses annotation line and puts result into the pre-parsed buffer
	 *
	 * @param annotationLine - string with annotation after marker
	 */
	void parseAnnotation(CharSequence annotationLine, int baseOffset)
	{
		Matcher m = annotationPattern.matcher(annotationLine);
		preparsedTokensList.clear();
		CharSequence tailComment;

		if (m.matches())
		{
//			String annotationKey = m.group(1);
			IElementType tokenType = PerlAnnotations.TOKEN_TYPES.get(m.group(1));

			if (tokenType == null)
				tokenType = ANNOTATION_UNKNOWN_KEY;

			preparsedTokensList.add(new CustomToken(baseOffset, baseOffset + m.group(1).length(), tokenType));
			baseOffset += m.group(1).length();

			if (m.group(2) != null)
			{
				preparsedTokensList.add(new CustomToken(baseOffset, baseOffset + m.group(2).length(), TokenType.WHITE_SPACE));
				baseOffset += m.group(2).length();
			}

			if (tokenType == ANNOTATION_RETURNS_KEY && m.group(3) != null)
			{
				// additional parsing
				String annotationRest = m.group(3);
				Matcher pm = annotationPatternPackage.matcher(annotationRest);

				if (pm.matches())
				{
					if (pm.group(1) != null && pm.group(1).length() > 0)
					{
						preparsedTokensList.add(new CustomToken(baseOffset, baseOffset + pm.group(1).length(), PACKAGE));
						baseOffset += pm.group(1).length();
					}

					tailComment = pm.group(2);
				} else
					tailComment = m.group(3);
			} else
				tailComment = m.group(3);
		} else
			tailComment = annotationLine;

		if (tailComment != null && tailComment.length() > 0)
			preparsedTokensList.add(new CustomToken(baseOffset, baseOffset + tailComment.length(), COMMENT_LINE));
	}

	/**
	 * Checking if comment is ended. Implemented for overriding in {@link EmbeddedPerlLexer#isLineCommentEnd(int)} }
	 *
	 * @param currentPosition current position to check
	 * @return checking result
	 */
	public boolean isLineCommentEnd(int currentPosition)
	{
		return getBuffer().charAt(currentPosition) == '\n';
	}

	/**
	 * Captures pod block from current position
	 *
	 * @return PERL_POD token type
	 */
	public IElementType capturePodBlock()
	{
		CharSequence buffer = getBuffer();
		int tokenStart = getTokenEnd();
		setTokenStart(tokenStart);
		int bufferEnd = buffer.length();

		int currentPosition = tokenStart;
		int linePos = currentPosition;

		while (true)
		{
			while (linePos < bufferEnd && buffer.charAt(linePos) != '\n')
			{
				linePos++;
			}
			if (linePos < bufferEnd && buffer.charAt(linePos) == '\n')
				linePos++;
			String line = buffer.subSequence(currentPosition, linePos).toString();
			currentPosition = linePos;

			if (linePos == bufferEnd || line.startsWith("=cut"))
			{
				setTokenEnd(linePos);
				break;
			}
		}

		return POD;
	}

	/**
	 * Processing captured heredoc opener. Stores marker and switches to proper lexical state
	 *
	 * @return PERL_OPERATOR  for << operator
	 */
	public IElementType parseHeredocOpener()
	{
		CharSequence openToken = yytext();
		Matcher m;
		int newState = LEX_HEREDOC_WAITING;

		if (StringUtil.endsWithChar(openToken, '"'))
		{
			m = markerPatternDQ.matcher(openToken);
			newState = LEX_HEREDOC_WAITING_QQ;
		} else if (StringUtil.endsWithChar(openToken, '\''))
			m = markerPatternSQ.matcher(openToken);
		else if (StringUtil.endsWithChar(openToken, '`'))
		{
			m = markerPatternXQ.matcher(openToken);
			newState = LEX_HEREDOC_WAITING_QX;
		} else
			m = markerPattern.matcher(openToken);

		Character nextCharacter = getNextSignificantCharacter();
		yypushback(openToken.length() - 2);

		if (m.matches())
		{
			preparsedTokensList.clear();
			int currentPosition = getNextTokenStart();

			if (m.groupCount() > 1)    // quoted heredoc
			{
				heredocMarker = m.group(3);

				int elementLength = m.group(1).length();
				if (elementLength > 0)    // got spaces
					preparsedTokensList.add(new CustomToken(currentPosition, currentPosition + elementLength, TokenType.WHITE_SPACE));

				currentPosition += elementLength;

				preparsedTokensList.add(new CustomToken(currentPosition, currentPosition + 1, getOpenQuoteTokenType(m.group(2).charAt(0))));
				currentPosition++;

				preparsedTokensList.add(new CustomToken(currentPosition, currentPosition + heredocMarker.length(), STRING_CONTENT));
				currentPosition += heredocMarker.length();

				preparsedTokensList.add(new CustomToken(currentPosition, currentPosition + 1, getCloseQuoteTokenType(m.group(2).charAt(0))));
			} else if (m.group(1).matches("\\d+"))    // check if it's numeric shift
				return OPERATOR_SHIFT_LEFT;
			else    // bareword heredoc
			{
				if (nextCharacter != null && nextCharacter.equals('('))    // it's a sub
					return OPERATOR_SHIFT_LEFT;

				heredocMarker = m.group(1);
				preparsedTokensList.add(new CustomToken(currentPosition, currentPosition + heredocMarker.length(), STRING_CONTENT));
			}
		} else
			throw new RuntimeException("Unable to parse HEREDOC opener " + openToken);

		pushState();
		yybegin(newState);

		return OPERATOR_HEREDOC;
	}

	/**
	 * Captures HereDoc document and returns appropriate token type
	 *
	 * @return Heredoc token type
	 */
	public IElementType captureHereDoc()
	{
		int oldState = yystate();
		IElementType tokenType = HEREDOC;
		if (oldState == LEX_HEREDOC_WAITING_QQ)
			tokenType = HEREDOC_QQ;
		else if (oldState == LEX_HEREDOC_WAITING_QX)
			tokenType = HEREDOC_QX;

		popState();
		CharSequence buffer = getBuffer();
		int tokenStart = getTokenEnd();
		setTokenStart(tokenStart);
		int bufferEnd = buffer.length();

		int currentPosition = tokenStart;
		int linePos = currentPosition;

		while (true)
		{
			while (linePos < bufferEnd && buffer.charAt(linePos) != '\n' && buffer.charAt(linePos) != '\r')
				linePos++;
			int lineContentsEnd = linePos;

			if (linePos < bufferEnd && buffer.charAt(linePos) == '\r')
				linePos++;
			if (linePos < bufferEnd && buffer.charAt(linePos) == '\n')
				linePos++;

			// reached the end of heredoc and got end marker
			if (heredocMarker.equals(buffer.subSequence(currentPosition, lineContentsEnd).toString()))
			{
				preparsedTokensList.clear();
				preparsedTokensList.add(new CustomToken(currentPosition, lineContentsEnd, HEREDOC_END));

				// non-empty heredoc and got the end
				if (currentPosition > tokenStart)
				{
					setTokenStart(tokenStart);
					setTokenEnd(currentPosition);
					return tokenType;
				}
				// empty heredoc and got the end
				else
					return getPreParsedToken();
			}
			// reached the end of file
			else if (linePos == bufferEnd)
			{
				// non-empty heredoc and got the end of file
				if (currentPosition > tokenStart)
				{
					setTokenStart(tokenStart);
					setTokenEnd(currentPosition);
					return tokenType;
				}
				// empty heredoc and got the end of file
				else
					return null;
			}
			currentPosition = linePos;
		}
	}

	/**
	 * Captures format; fixme refactor with captureHeredoc got common parts
	 *
	 * @return Heredoc token type
	 */
	public IElementType captureFormat()
	{
		popState();
		CharSequence buffer = getBuffer();
		int tokenStart = getTokenEnd();
		setTokenStart(tokenStart);
		int bufferEnd = buffer.length();

		int currentPosition = tokenStart;
		int linePos = currentPosition;

		while (true)
		{
			while (linePos < bufferEnd && buffer.charAt(linePos) != '\n' && buffer.charAt(linePos) != '\r')
				linePos++;
			int lineContentsEnd = linePos;

			if (linePos < bufferEnd && buffer.charAt(linePos) == '\r')
				linePos++;
			if (linePos < bufferEnd && buffer.charAt(linePos) == '\n')
				linePos++;

			// reached the end of heredoc and got end marker
			if (".".equals(buffer.subSequence(currentPosition, lineContentsEnd).toString()))
			{
				preparsedTokensList.clear();
				preparsedTokensList.add(new CustomToken(currentPosition, lineContentsEnd, FORMAT_TERMINATOR));

				// non-empty heredoc and got the end
				if (currentPosition > tokenStart)
				{
					setTokenStart(tokenStart);
					setTokenEnd(currentPosition);
					return FORMAT;
				}
				// empty format and got the end
				else
					return getPreParsedToken();
			}
			// reached the end of file
			else if (linePos == bufferEnd)
			{
				// non-empty format and got the end of file
				if (currentPosition > tokenStart)
				{
					setTokenStart(tokenStart);
					setTokenEnd(currentPosition);
					return FORMAT;
				}
				// empty heredoc and got the end of file
				else
					return null;
			}
			currentPosition = linePos;
		}
	}

	public void reset(CharSequence buf, int start, int end, int initialState)
	{
		super.reset(buf, start, end, initialState);
		resetInternals();
//		System.err.println(String.format("Lexer re-set to %d - %d, %d of %d", start, end, end - start, buf.length()));
	}

	/**
	 * Disallows sharp delimiter on space occurance for quote-like operations
	 *
	 * @return whitespace token type
	 */
	public IElementType processOpenerWhiteSpace()
	{
		allowSharpQuote = false;
		return TokenType.WHITE_SPACE;
	}


	// guess if this is a OPERATOR_DIV or regex opener
	public IElementType guessDiv()
	{
		if (    // seems regex
			// todo we should check argumentless prefix sub
			// todo we should check if we are after grep/map/sort block
				!SIGILS_TOKENS.contains(lastUnbraceTokenType)    // for $/
						&& (
						lastSignificantTokenType == null
								|| OPERATORS_TOKENSET.contains(lastSignificantTokenType)
								|| RESERVED_TOKENSET.contains(lastSignificantTokenType)
								|| REGEXP_PREFIX.contains(lastSignificantTokenType)
								|| lastUnparenTokenType == IDENTIFIER && REGEXP_PREFIX_SUBS.contains(lastUnparenToken)
				))
		{
			allowSharpQuote = true;
			isEscaped = false;
			regexCommand = "m";
			sectionsNumber = 1;

			pushState();
			yypushback(1);
			yybegin(LEX_REGEX_OPENER);

			return null;
		} else
		{
			Character nextCharacter = getNextCharacter();

			if (nextCharacter != null && nextCharacter.equals('/'))
			{
				setTokenEnd(getNextTokenStart() + 1);
				return OPERATOR_OR_DEFINED;
			} else
			{
				return OPERATOR_DIV;
			}
		}
	}

	// fixme how about $x234sdfsdf ?
	public IElementType checkOperatorXSticked()
	{
		yypushback(1);
		if (lastSignificantTokenType == RESERVED_REQUIRE                            // require x123
				|| IDENTIFIER_NEGATION_PREFIX.contains(lastSignificantTokenType)    // package x123, ->x123, etc.
				|| SIGILS_TOKENS.contains(lastTokenType)                            // $x123
				|| isBraced()                                                        // {x123}
				)
			return IDENTIFIER;
		else if (isCommaArrowAhead())    // we should check for ->
			return STRING_CONTENT;

		yypushback(yylength() - 1);
		return OPERATOR_X;
	}

	public IElementType parseCappedVariableName()
	{
		if (SIGILS_TOKENS.contains(lastUnbraceTokenType))
			return IDENTIFIER;

		yypushback(yylength() - 1);
		return OPERATOR_BITWISE_XOR;
	}

	/**
	 * Sets up regex parser
	 */
	public void processRegexOpener()
	{
		allowSharpQuote = true;
		isEscaped = false;
		regexCommand = yytext().toString();

		if ("s".equals(regexCommand))    // two sections s
			sectionsNumber = 2;
		else                        // one section qr m
			sectionsNumber = 1;

		pushState();
		yybegin(LEX_REGEX_OPENER);
	}

	/**
	 * Parses regexp from the current position (opening delimiter) and preserves tokens in preparsedTokensList
	 * REGEX_MODIFIERS = [msixpodualgcer]
	 *
	 * @return opening delimiter type
	 */
	public IElementType parseRegex()
	{
		popState();
		preparsedTokensList.clear();

		CharSequence buffer = getBuffer();
		int bufferEnd = getBufferEnd();

		// find block 1
		RegexBlock firstBlock = RegexBlock.parseBlock(buffer, getTokenStart() + 1, bufferEnd, yytext().charAt(0), false);

		if (firstBlock == null)
		{
//			System.err.println("Stop after first block");
			yybegin(YYINITIAL);
			return REGEX_QUOTE_OPEN;
		}
		int currentOffset = firstBlock.getEndOffset();

		// find block 2
		ArrayList<CustomToken> betweenBlocks = new ArrayList<CustomToken>();
		RegexBlock secondBLock = null;
		CustomToken secondBlockOpener = null;

		if (sectionsNumber == 2 && currentOffset < bufferEnd)
		{
			if (firstBlock.hasSameQuotes())
			{
				secondBLock = RegexBlock.parseBlock(buffer, currentOffset, bufferEnd, firstBlock.getOpeningQuote(), true);
			} else
			{
				// spaces and comments between if {}, fill betweenBlock
				while (true)
				{
					char currentChar = buffer.charAt(currentOffset);
					if (RegexBlock.isWhiteSpace(currentChar))    // white spaces
					{
						int whiteSpaceStart = currentOffset;
						while (RegexBlock.isWhiteSpace(buffer.charAt(currentOffset)))
						{
							currentOffset++;
						}
						betweenBlocks.add(new CustomToken(whiteSpaceStart, currentOffset, TokenType.WHITE_SPACE));
					} else if (currentChar == '#')    // line comment
					{
						int commentStart = currentOffset;
						while (buffer.charAt(currentOffset) != '\n')
						{
							currentOffset++;
						}
						betweenBlocks.add(new CustomToken(commentStart, currentOffset, COMMENT_LINE));
					} else
						break;
				}

				// read block
				secondBlockOpener = new CustomToken(currentOffset, currentOffset + 1, REGEX_QUOTE_OPEN);
				secondBLock = RegexBlock.parseBlock(buffer, currentOffset + 1, bufferEnd, buffer.charAt(currentOffset), true);
			}

			if (secondBLock == null)
			{
//				System.err.println("Stop after second block");
				yybegin(YYINITIAL);
				return REGEX_QUOTE_OPEN;
			}
			currentOffset = secondBLock.getEndOffset();
		}

		// check modifiers for x
		boolean isExtended = false;
		boolean isEvaluated = false;
		List<Character> allowedModifiers = RegexBlock.allowedModifiers.get(regexCommand);
		int modifiersEnd = currentOffset;
		ArrayList<CustomToken> modifierTokens = new ArrayList<CustomToken>();

		while (true)
		{
			if (modifiersEnd == bufferEnd)    // eof
				break;
			else if (!allowedModifiers.contains(buffer.charAt(modifiersEnd)))    // unknown modifier
				break;
			else if (buffer.charAt(modifiersEnd) == 'x')    // mark as extended
				isExtended = true;
			else if (buffer.charAt(modifiersEnd) == 'e')    // mark as evaluated
			{
				isEvaluated = true;
				if (secondBlockOpener != null)
					secondBlockOpener.setTokenType(REGEX_QUOTE_OPEN_E);
			}

			modifierTokens.add(new CustomToken(modifiersEnd, modifiersEnd + 1, REGEX_MODIFIER));

			modifiersEnd++;
		}

		// parse block 1
		preparsedTokensList.addAll(firstBlock.tokenize(getStringLexer(), isExtended, false));

		if (secondBLock != null)
		{
			// parse spaces
			preparsedTokensList.addAll(betweenBlocks);

			if (secondBlockOpener != null)
				preparsedTokensList.add(secondBlockOpener);
			else if (isEvaluated)
				preparsedTokensList.getLast().setTokenType(REGEX_QUOTE_E);
			else
				preparsedTokensList.getLast().setTokenType(REGEX_QUOTE);


			// parse block 2
			if (isEvaluated)
			{
				if (evalPerlLexer == null)
					evalPerlLexer = new PerlLexerAdapter(myProject);
				preparsedTokensList.addAll(secondBLock.parseEval(evalPerlLexer));
			} else
				preparsedTokensList.addAll(secondBLock.tokenize(getStringLexer(), isExtended, true));
		}

		// parse modifiers
		preparsedTokensList.addAll(modifierTokens);

		return REGEX_QUOTE_OPEN;
	}

	/**
	 * Transliteration processors tr y
	 **/

	public void processTransOpener()
	{
		allowSharpQuote = true;
		isEscaped = false;
		currentSectionNumber = 0;
		pushState();
		yybegin(LEX_TRANS_OPENER);
	}

	public IElementType processTransQuote()
	{
		charOpener = yytext().charAt(0);
		if (charOpener == '#' && !allowSharpQuote)
		{
			yypushback(1);
			popState();
			return null;
		} else charCloser = RegexBlock.getQuoteCloseChar(charOpener);

		yybegin(LEX_TRANS_CHARS);
		stringContentStart = getTokenStart() + 1;

		return REGEX_QUOTE_OPEN;
	}

	public IElementType processTransChar()
	{
		char currentChar = yytext().charAt(0);

		if (currentChar == charCloser && !isEscaped)
		{
			yypushback(1);
			setTokenStart(stringContentStart);
			yybegin(LEX_TRANS_CLOSER);
			return STRING_CONTENT;
		} else if (isLastToken())
		{
			setTokenStart(stringContentStart);
			return STRING_CONTENT;
		} else
			isEscaped = (currentChar == '\\' && !isEscaped);

		return null;
	}

	public IElementType processTransCloser()
	{
		setTokenStart(getNextTokenStart());
		setTokenEnd(getTokenStart() + 1);
		if (currentSectionNumber == 0) // first section
		{
			currentSectionNumber++;
			if (charCloser == charOpener) // next is replacements block
			{
				yybegin(LEX_TRANS_CHARS);
				stringContentStart = getTokenStart() + 1;
			} else    // next is new opener, possibly other
			{
				yybegin(LEX_TRANS_OPENER);
			}
		} else // last section
		{
			yybegin(LEX_TRANS_MODIFIERS);
		}
		return REGEX_QUOTE_CLOSE;
	}

	/**
	 * Quote-like string procesors
	 **/
	public void processQuoteLikeStringOpener(IElementType tokenType)
	{
		allowSharpQuote = true;
		isEscaped = false;
		pushState();
		if (tokenType == RESERVED_Q)
			yybegin(LEX_QUOTE_LIKE_OPENER);
		else if (tokenType == RESERVED_QQ)
			yybegin(LEX_QUOTE_LIKE_OPENER_QQ);
		else
			yybegin(LEX_QUOTE_LIKE_OPENER_QX);
	}

	public IElementType getOpenQuoteTokenType(char quoteCharacter)
	{
		if (quoteCharacter == '"')
			return QUOTE_DOUBLE_OPEN;
		else if (quoteCharacter == '`')
			return QUOTE_TICK_OPEN;
		else if (quoteCharacter == '\'')
			return QUOTE_SINGLE_OPEN;
		else
			throw new RuntimeException("Unknown open quote type " + quoteCharacter);
	}

	public IElementType getCloseQuoteTokenType(char quoteCharacter)
	{
		if (quoteCharacter == '"')
			return QUOTE_DOUBLE_CLOSE;
		else if (quoteCharacter == '`')
			return QUOTE_TICK_CLOSE;
		else if (quoteCharacter == '\'')
			return QUOTE_SINGLE_CLOSE;
		else
			throw new RuntimeException("Unknown close quote type " + quoteCharacter);
	}

	public IElementType getStringTokentType()
	{
		int currentState = yystate();
		if (currentState == LEX_QUOTE_LIKE_OPENER)
			return PARSABLE_STRING_Q;
		if (currentState == LEX_QUOTE_LIKE_OPENER_QQ)
			return PARSABLE_STRING_QQ;
		if (currentState == LEX_QUOTE_LIKE_OPENER_QX)
			return PARSABLE_STRING_QX;

		throw new RuntimeException("Unknown lexical state for string token " + currentState);
	}

	/**
	 * Quote-like list procesors
	 **/

	public void processQuoteLikeListOpener()
	{
		allowSharpQuote = true;
		pushState();
		yybegin(LEX_QUOTE_LIKE_LIST_OPENER);
	}

	public IElementType processQuoteLikeListQuote()
	{
		charOpener = yytext().charAt(0);

		if (charOpener == '#' && !allowSharpQuote)
		{
			yypushback(1);
			yybegin(YYINITIAL);
			return null;
		} else charCloser = RegexBlock.getQuoteCloseChar(charOpener);

		yybegin(LEX_QUOTE_LIKE_WORDS);

		return QUOTE_SINGLE_OPEN;
	}

	public boolean waitingHereDoc()
	{
		int state = yystate();
		return state == LEX_HEREDOC_WAITING || state == LEX_HEREDOC_WAITING_QQ || state == LEX_HEREDOC_WAITING_QX;
	}

	public IElementType processSemicolon()
	{
		if (!waitingHereDoc())
			yybegin(YYINITIAL);
		else
		{
			stateStack.pop();
			stateStack.push(YYINITIAL);
		}
		return SEMICOLON;
	}

	/**
	 * Parses IDENTIFIER =>
	 * can be string_content => or ->identifier
	 *
	 * @return token type
	 */
	public IElementType parseBarewordMinus()
	{
		String tokenText = yytext().toString();

		boolean negate = IDENTIFIER_NEGATION_PREFIX.contains(lastSignificantTokenType) || SIGILS_TOKENS.contains(lastTokenType);

		if (Character.isDigit(tokenText.charAt(0)))
		{
			int endOffset = 1;
			while (Character.isDigit(tokenText.charAt(endOffset)))
				endOffset++;

			yypushback(tokenText.length() - endOffset);
			return NUMBER_SIMPLE;
		} else if (!negate && isBraced())
			return IDENTIFIER;
		else if (!negate && isCommaArrowAhead())
			return STRING_CONTENT;
		else if (tokenText.startsWith("--"))
		{
			yypushback(tokenText.length() - 2);
			return OPERATOR_MINUS_MINUS;
		} else if (StringUtil.startsWithChar(tokenText, '-'))
		{
			yypushback(tokenText.length() - 1);
			return OPERATOR_MINUS;
		}

		return getIdentifierToken();
	}

	/**
	 * Bareword parser, resolves built-ins and runs additional processings where it's necessary
	 *
	 * @return token type
	 */
	public IElementType getIdentifierToken()
	{
		String tokenText = yytext().toString();
		IElementType tokenType;

		if (!IDENTIFIER_NEGATION_PREFIX.contains(lastSignificantTokenType)
				&& !SIGILS_TOKENS.contains(lastTokenType)    // print $$ if smth

				)
		{
			if ((tokenType = namedOperators.get(tokenText)) != null)
				return tokenType;
			else if (
					lastUnparenTokenType == IDENTIFIER
							&& PerlParserUtil.PRE_HANDLE_OPS.contains(lastUnparenToken)
							&& !PerlSubUtil.BUILT_IN.contains(tokenText)
							&& isListElementEndAhead()
					)
				return HANDLE;
			else if ((tokenType = reservedTokenTypes.get(tokenText)) != null)
			{
				if (tokenType == RESERVED_QW)
					processQuoteLikeListOpener();
				else if (tokenType == RESERVED_TR || tokenType == RESERVED_Y)
					processTransOpener();
				else if (tokenType == RESERVED_Q || tokenType == RESERVED_QQ || tokenType == RESERVED_QX)
					processQuoteLikeStringOpener(tokenType);
				else if (tokenType == RESERVED_S || tokenType == RESERVED_M || tokenType == RESERVED_QR)
					processRegexOpener();
				else if (tokenType == RESERVED_FORMAT)
				{
					pushState();
					yybegin(LEX_FORMAT_WAITING);
				}
				return tokenType;
			} else if ((tokenType = blockNames.get(tokenText)) != null)
				return tokenType;
			else if ((tokenType = tagNames.get(tokenText)) != null)
				return tokenType;
		} else if (lastSignificantTokenType == RESERVED_USE || lastSignificantTokenType == RESERVED_NO) // pragma section
			if (PRAGMA_TOKENS_MAP.containsKey(tokenText))
				return PRAGMA_TOKENS_MAP.get(tokenText);

		return IDENTIFIER;
	}

	/**
	 * Splitting ambiguous package to PACKAGE_IDENTIFIER and IDENTIFIER
	 *
	 * @return token type
	 */
	public IElementType parsePackage()
	{
		String tokenText = yytext().toString();

		// check if it's cmp'
		if (tokenText.length() > 4 && tokenText.charAt(3) == '\'' && tokenText.substring(0, 3).equals("cmp"))
		{
			yypushback(tokenText.length() - 3);
			return getIdentifierToken();
		}
		// check if it's qw|qr|qx|qq|tr|ne|eq|gt|lt|ge|le'
		else if (tokenText.length() > 3 && tokenText.charAt(2) == '\'' && PACKAGE_EXCEPTIONS.contains(tokenText.substring(0, 2)))
		{
			yypushback(tokenText.length() - 2);
			return getIdentifierToken();
		}
		// check if it's m|q|s|y'
		else if (tokenText.length() > 2 && tokenText.charAt(1) == '\'' && PACKAGE_EXCEPTIONS.contains(tokenText.substring(0, 1)))
		{
			yypushback(tokenText.length() - 1);
			return getIdentifierToken();
		}

		Matcher m = AMBIGUOUS_PACKAGE_RE.matcher(tokenText);
		if (m.matches())
		{
			String packageIdentifier = m.group(1);
			String identifier = m.group(2);

			preparsedTokensList.clear();
			int packageIdentifierEnd = getTokenStart() + packageIdentifier.length();
			CustomToken barewordToken = new CustomToken(packageIdentifierEnd, getTokenEnd(), IDENTIFIER);
			preparsedTokensList.add(barewordToken);
			setTokenEnd(packageIdentifierEnd);

			IElementType packageTokenType = parsePackageCanonical();

			if (packageTokenType == PACKAGE_CORE_IDENTIFIER && reservedTokenTypes.containsKey(identifier))
				barewordToken.setTokenType(reservedTokenTypes.get(identifier));
			return packageTokenType;

		} else
			throw new RuntimeException("Inappropriate package name " + tokenText);
	}

	private Character getNextCharacter()
	{
		int currentPosition = getTokenEnd();
		int bufferEnd = getBufferEnd();
		CharSequence buffer = getBuffer();
		if (currentPosition < bufferEnd)
			return buffer.charAt(currentPosition);
		return null;
	}

	// checks if ahead is comma, semi, close brace
	private boolean isListElementEndAhead()
	{
		int nextPosition = getNextSignificantCharacterPosition(getTokenEnd());
		if (nextPosition > -1)
		{
			CharSequence buffer = getBuffer();
			char nextChar = buffer.charAt(nextPosition);
			if (
					nextChar == ','
							|| nextChar == ';'
							|| nextChar == ')'
							|| nextChar == '='
							&& nextPosition + 1 < buffer.length()
							&& buffer.charAt(nextPosition + 1) == '>'
					)
				return true;
		}
		return false;
	}

	// checks if ahead is =>
	private boolean isCommaArrowAhead()
	{
		int nextPosition = getNextSignificantCharacterPosition(getTokenEnd());
		if (nextPosition > -1)
		{
			CharSequence buffer = getBuffer();
			if (
					buffer.charAt(nextPosition) == '='
							&& nextPosition + 1 < buffer.length()
							&& buffer.charAt(nextPosition + 1) == '>'
					)
				return true;
		}
		return false;
	}

	@Override
	public IElementType parseOperatorDereference()
	{
		if (lastTokenType == SIGIL_SCALAR)    // suppose it's a $->
		{
			yypushback(1);
			return IDENTIFIER;
		}
		return OPERATOR_DEREFERENCE;
	}

	/**
	 * Checks if buffer at current offset contains specific string
	 *
	 * @param buffer  CharSequence buffer
	 * @param offset  offset
	 * @param pattern string to search
	 * @return search result
	 */
	public boolean bufferAtString(CharSequence buffer, int offset, String pattern)
	{
		int patternEnd = offset + pattern.length();
		return buffer.length() >= patternEnd && buffer.subSequence(offset, patternEnd).toString().equals(pattern);
	}

	public void registerToken(IElementType tokenType, String tokenText)
	{
		super.registerToken(tokenType, tokenText);

		// fixme refactor this
		if (!PerlParserDefinition.WHITE_SPACE_AND_COMMENTS.contains(tokenType))
			if (yystate() == YYINITIAL && tokenType != SEMICOLON) // to ensure proper highlighting reparsing
				yybegin(LEX_CODE);
	}

	public IElementType processWhiteSpace()
	{
		allowSharpQuote = false;
		return TokenType.WHITE_SPACE;
	}

	public IElementType processNewLine()
	{
		allowSharpQuote = false;
		return TokenType.NEW_LINE_INDENT;
	}
}
