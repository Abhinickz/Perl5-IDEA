{
  parserClass="com.perl5.lang.perl.parser.PerlParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Perl"
  psiImplClassSuffix="Impl"
  psiPackage="com.perl5.lang.perl.psi"
  psiImplPackage="com.perl5.lang.perl.psi.impl"

  elementTypeHolderClass="com.perl5.lang.perl.lexer.PerlElementTypes"
  elementTypeClass="com.perl5.lang.perl.PerlElementType"
  tokenTypeClass="com.perl5.lang.perl.PerlTokenType"

  tokens=[
    PERL_COMMENT="PERL_COMMENT"
    PERL_COMMENT_BLOCK="PERL_COMMENT_BLOCK"
    PERL_POD="PERL_POD"

    PERL_SIGIL_ARRAY="@"
    PERL_SIGIL_HASH="%"
    PERL_SIGIL_SCALAR="$"

    PERL_MULTILINE_MARKER="PERL_MULTILINE_MARKER"
    PERL_MULTILINE_MARKER_HTML="PERL_MULTILINE_MARKER_HTML"
    PERL_MULTILINE_MARKER_XHTML="PERL_MULTILINE_MARKER_XHTML"
    PERL_MULTILINE_MARKER_XML="PERL_MULTILINE_MARKER_XML"

    PERL_STRING_MULTILINE="PERL_STRING_MULTILINE"

    PERL_STRING="PERL_STRING"

    PERL_VERSION="PERL_VERSION"
    PERL_NUMBER="PERL_NUMBER"
    PERL_SCALAR="PERL_SCALAR"
    PERL_ARRAY="PERL_ARRAY"
    PERL_HASH="PERL_HASH"
    PERL_GLOB="PERL_GLOB"

    PERL_FUNCTION="PERL_FUNCTION"
    PERL_PACKAGE="PERL_PACKAGE"
    PERL_OPERATOR="PERL_OPERATOR"

    PERL_DEREFERENCE='->'
    PERL_DEPACKAGE='::'
    PERL_COMMA=','
    PERL_LBRACK='['
    PERL_RBRACK=']'
    PERL_LPAREN='('
    PERL_RPAREN=')'
    PERL_LBRACE='{'
    PERL_RBRACE='}'
    PERL_SEMI=';';
  ]

    psiImplUtilClass="com.perl5.lang.perl.psi.impl.PerlPsiImpUtil"
}

perlFile ::= block_item*

private function_definition ::= function_definition_named | function_definition_anon
function_definition_named ::= 'sub' function block ';' ? {
    mixin="com.perl5.lang.perl.psi.impl.PerlFunctionDefinitionNamedUtil"
}
function_definition_anon ::= 'sub' block ';'

package_namespace ::= 'package' package_bare PERL_VERSION ? (block | ';' package_item * )

block ::= '{' block_item* '}'

private block_item ::= package_namespace | package_item | package_definition_invalid
private package_item ::= function_definition | if_block | code_line_valid | PERL_POD | PERL_COMMENT | PERL_COMMENT_BLOCK | block | code_line_invalid

private code_line_element ::= method_call | function_call| function | array_value | hash_value | scalar_value | glob |  multiline_string | multiline_marker | PERL_OPERATOR
private code_line_elements ::= code_line_element +

private code_line_valid ::= eval | package_use | package_no | package_require | code_line

private code_line_invalid ::=
    package_use_invalid
    | package_no_invalid
    | package_require_invalid
    | eval_invalid

package_definition_invalid ::= 'package' code_line_invalid_element*';'
package_use_invalid ::= 'use' code_line_invalid_element*';'
package_no_invalid ::= 'no' code_line_invalid_element*';'
package_require_invalid ::= 'require' code_line_invalid_element*';';
eval_invalid ::= 'eval' code_line_invalid_element * ';'

code_line_invalid_element ::= code_line_element | package_bare | PERL_VERSION | controls | chars;

package_use ::= 'use' package_use_arguments ';'
package_no ::= 'no' package_use_arguments ';'

private package_use_arguments ::=
    package_bare PERL_VERSION call_params ?
    | package_bare call_params ?
    | PERL_VERSION;

package_require ::= 'require' (package_bare | PERL_VERSION | string) ';'

eval ::= 'eval' (block | scalar_value) ';'

if_block ::= ('if' | 'unless') if_branch_conditional if_block_elsif * if_block_else ?
if_block_elsif ::= 'elsif' if_branch_conditional
if_block_else  ::= 'else' if_branch
if_branch_conditional ::= '(' expression ')' if_branch
if_branch ::= (code_line | block )
expression ::= (code_line_elements | subexpression) +
subexpression ::= '(' code_line_elements ')'

method_call ::= package_static_call | package_object_call | object_call
object_call ::= scalar_value_var '->' function_call_any
package_static_call ::= package_bare '::' function_call_any
package_object_call ::= package_bare '->' function_call_any

function_call_any ::= PERL_FUNCTION call_params_any ?
function_call ::= function call_params_any ?
call_params_any ::= call_params_strict | call_params
call_params_strict ::= '(' call_params ')'
call_params ::= call_param ? (',' call_param ) *
call_param ::= array_value | scalar_value

code_line ::= code_line_element* ';' multiline_string ?

array_value ::= array_value_item (',' (array_value_item | scalar_value  )) *
private array_value_item ::= array_dereference | array_slice | hash_slice | hash_value | array
private array_slice ::= array '[' (array_value | scalar_value) ']'
private hash_slice ::= array '{' (array_value | scalar_value) '{'
private array_dereference ::= PERL_SIGIL_ARRAY '{' scalar_value '}'

hash_value ::= hash_dereference | hash
private hash_dereference ::= PERL_SIGIL_HASH '{' scalar_value '}'

scalar_value ::= string | PERL_NUMBER | PERL_VERSION | multiline_marker| scalar_anon_array | scalar_anon_hash | scalar_value_var
private scalar_value_var ::= scalar_dereference | scalar_hash_element | scalar_array_element | scalar | scalar_function_result // dynamic scalar, may be a reference
private scalar_hash_element ::= scalar '{' scalar_value '}'
private scalar_array_element ::= scalar '[' scalar_value ']'
private scalar_dereference ::= PERL_SIGIL_SCALAR '{' scalar_value '}'
private scalar_anon_array     ::= '[' array_value ']'
private scalar_anon_hash      ::= '{' array_value '}'
private scalar_function_result ::= function_call

// this just for wrapper, need to find other way
function ::= PERL_FUNCTION
glob ::= PERL_GLOB
scalar ::= PERL_SCALAR
array ::= PERL_ARRAY
hash ::= PERL_HASH
string ::= PERL_STRING

// Generalizations
private controls ::= ',' | '[' | ']' | '(' | ')'

private multiline_string ::= PERL_STRING_MULTILINE PERL_MULTILINE_MARKER

// opening marker
private multiline_marker ::= PERL_MULTILINE_MARKER
    | PERL_MULTILINE_MARKER_HTML
    | PERL_MULTILINE_MARKER_XHTML
    | PERL_MULTILINE_MARKER_XML

package_bare ::= PERL_PACKAGE  {   mixin="com.perl5.lang.perl.psi.impl.PerlNamedElementImpl"
        implements="com.perl5.lang.perl.psi.PerlNamedElement"
        methods=[getName setName getNameIdentifier]
    }

