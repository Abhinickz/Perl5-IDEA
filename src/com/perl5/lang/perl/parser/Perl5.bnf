{
  parserClass="com.perl5.lang.perl.parser.PerlParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

//  generate=[tokens="yes" psi="yes" tokenAccessors="yes"]

  psiClassPrefix="Perl"
  psiImplClassSuffix="Impl"
  psiPackage="com.perl5.lang.perl.psi"
  psiImplPackage="com.perl5.lang.perl.psi.impl"

  elementTypeHolderClass="com.perl5.lang.perl.lexer.PerlElementTypes"
  elementTypeClass="com.perl5.lang.perl.PerlElementType"
  tokenTypeClass="com.perl5.lang.perl.PerlTokenType"

  parserUtilClass="com.perl5.lang.perl.parser.PerlParserUitl"
  psiImplUtilClass="com.perl5.lang.perl.psi.impl.PerlPsiImpUtil"

  //elementTypeFactory="com.perl5.lang.perl.psi.PerlElementFactory.getCompositeType"
//  tokenTypeFactory="com.perl5.lang.perl.psi.PerlElementFactory.getCompositeType"

  tokens=[
    PERL_COMMENT="PERL_COMMENT"
    PERL_COMMENT_BLOCK="PERL_COMMENT_BLOCK"
    PERL_POD="PERL_POD"

    PERL_SIGIL_ARRAY="@"
    PERL_SIGIL_HASH="%"
    PERL_SIGIL_SCALAR="$"

    PERL_SCALAR="PERL_SCALAR"
    PERL_ARRAY="PERL_ARRAY"
    PERL_HASH="PERL_HASH"
    PERL_GLOB="PERL_GLOB"

    PERL_STRING_MULTILINE="PERL_STRING_MULTILINE" // should be string content too
    PERL_STRING_MULTILINE_END="PERL_STRING_MULTILINE_END"

    PERL_NUMBER_VERSION="PERL_NUMBER_VERSION"
    PERL_NUMBER="PERL_NUMBER"

    PERL_KEYWORD="PERL_KEYWORD"
    PERL_OPERATOR="PERL_OPERATOR"

    PERL_STRING="PERL_STRING"
    PERL_STRING_CONTENT="PERL_STRING_CONTENT"

    PERL_BAREWORD="PERL_BAREWORD"
    PERL_TAG="PERL_TAG"

    PERL_ARROW_COMMA='=>'
    PERL_DEPACKAGE='::'
    PERL_LBRACK='['
    PERL_RBRACK=']'
    PERL_LPAREN='('
    PERL_RPAREN=')'
    PERL_LBRACE='{'
    PERL_RBRACE='}'
    PERL_SEMI=';';
    PERL_QUOTE="\""

    // custom tokens
    PERL_PACKAGE="PERL_PACKAGE"
    PERL_FUNCTION="PERL_FUNCTION"
  ]

    extends(".*expr")=expr
 }

perlFile ::= file_item*

block ::= '{' (file_item + | expr )? '}';
file_item ::= package_definition | package_element

private package_element ::=
    block_element (PERL_SEMI | <<eof>>) ?
    | line_element if_postfix ? (PERL_SEMI | <<eof>>) ?

private block_element ::=
    eval
    | sub_block_named
    | for_block
    | if_block
    | while_block
    | given_block
    | block_block
    | PERL_POD

private line_element ::=
    package_use
    | package_no
    | package_require
    | return_expr
    | last_expr
    | code_line

// package
package_definition ::= 'package' perl_package perl_version ? (block | PERL_SEMI package_element * )


sub_block_named ::= 'sub' perl_function block
//{
//    mixin="com.perl5.lang.perl.psi.impl.PerlFunctionDefinitionNamedUtil"
//}
sub_block_anon ::= 'sub' block

// variable definition
variable_definition ::= my_definition | our_definition | local_definition
my_definition ::= 'my' variable_definition_arguments
our_definition ::= 'our' variable_definition_arguments
local_definition ::= 'local' variable_definition_arguments
variable_definition_arguments ::= ( perl_package ? variable | '(' variables ')' )

// use and no
package_use ::= 'use' package_use_arguments
package_no ::= 'no' package_use_arguments

package_use_arguments ::=
    perl_package perl_version expr ?
    | perl_package expr ?
    | perl_version;

// return && exit
return_expr ::= ('return' | 'exit') expr ?

// last && next
last_expr ::= ('last' | 'next' | 'redo') expr ? // @todo labels

// require
package_require ::= 'require' (perl_package | perl_version | string) // multiline string is possible too

// eval
eval ::= 'eval' (block | scalar)

// if
if_postfix ::= ('if' | 'unless') expr

if_block ::= ('if' | 'unless') block_conditional if_block_elsif * if_block_else ?
if_block_elsif ::= 'elsif' block_conditional
if_block_else  ::= 'else' block

// for/foreach
for_block ::= ('foreach' | 'for') for_block_arguments
for_block_arguments ::=
    '(' expr ? PERL_SEMI expr ? PERL_SEMI expr ? ')' block
     | (variable_definition | variable ) '(' list_expr ')' block ('continue' block ) ?

given_block ::= 'given' block_conditional

while_block ::= ('until' | 'while' ) block_conditional ('continue' block ) ?

block_conditional ::= '(' expr ')' block
block_block ::= block ('continue' block ) ?

code_line ::= expr

//code_line_recover ::= !(PERL_RBRACE | PERL_SEMI)

// expression
expr ::=
    op_24_expr
    | op_23_expr
    | op_22_expr
    | op_21_expr
    | op_20_expr
    | op_19_expr
    | op_18_expr
    | op_17_expr
    | op_16_expr
    | op_15_expr
    | op_14_expr
    | op_13_expr
    | op_12_expr
    | op_11_expr
    | op_10_expr
    | op_9_expr
    | op_8_expr
    | op_7_expr
    | op_6_expr
    | op_5_expr
    | op_4_expr
    | op_3_expr
    | op_2_expr
    | op_1_expr

op_1_expr ::= term | grep_expr | sort_expr | call_leftward | variable_definition // not sure about var definition
op_2_expr ::= expr '->' expr
private op_3_expr ::= op_3_pref_expr | op_3_suff_expr
op_3_pref_expr ::= ('++'|'--') expr
op_3_suff_expr ::= expr ('++'|'--')
op_4_expr ::= expr ('**' expr)+ { rightAssociative=true }
op_5_expr ::= ('\' | '~'| '!'| '+' | '-') expr { rightAssociative=true }
op_6_expr ::= expr ('=~'|'!~') expr
op_7_expr ::= expr ('*'|'/'|'%'|'x') expr
op_8_expr ::= expr ('+'|'-'|'.') expr
op_9_expr ::= expr ('<<'|'>>') expr
op_10_expr ::= ('not'|'defined'|'ref'|'exists'|'scalar') expr
op_11_expr ::= expr ('>='|'<='|'<'|'>'|'lt'|'gt'|'le'|'ge') expr
op_12_expr ::= expr ('=='|'!='|'<=>'|'eq'|'ne'|'cmp'|'~~') expr
op_13_expr ::= expr '&' expr
op_14_expr ::= expr ('|'|'^') expr
op_15_expr ::= expr '&&' expr
op_16_expr ::= expr ('||'|'//') expr
op_17_expr ::= expr ('..'|'...') expr
op_18_expr ::= expr '?' expr ':' expr { rightAssociative=true }
op_19_expr ::= expr ('=' | '**='|'+='|'-='| '*='|'/='|'x='| '&='|'|='|'.='| '<<='|'>>='|'%='| '&&='|'||='|'^='| '//=') expr { rightAssociative=true }
op_20_expr ::= expr	(',' | '=>') expr
op_21_expr ::= call_rightward
op_22_expr ::= 'not' expr { rightAssociative=true }
op_23_expr ::= expr 'and' expr
op_24_expr ::= expr ('or'|'xor') expr

term ::=
    '(' expr ')'
    | list_expr
    | scalar

call_leftward ::=
    calee '(' call_arguments ? ')'
    | scalar '(' call_arguments ? ')'
    | scalar '->' '(' call_arguments ? ')'
call_rightward ::= calee call_arguments ?

call_arguments ::= expr

calee ::=
    package_method
    | perl_method_parent
    | object_method
    | perl_package_function
    | (perl_function perl_package)
    | perl_function
    | object_method_object

// @todo regexps
// @todo $proto->SUPER::smth
// @todo \& reference
package_method ::= perl_package '->' perl_function
object_method ::= scalar '->' perl_function
object_method_object ::= scalar '->' scalar

////////////////// list expressions ////////////////////////////
list_expr ::=
    sort_expr
    | keys_expr
    | grep_expr
    | qw_expr
    | '<' scalar? '>' // bareword should be here too
    | array
    | hash

qw_expr ::= 'qw' PERL_QUOTE PERL_STRING_CONTENT * PERL_QUOTE

shift_expr ::= ('shift' | 'pop') shift_expr_args ?
private shift_expr_args ::= list_expr | expr

// sort
sort_expr ::= 'sort' sort_op_args
sort_op_args ::=
    perl_function list_expr
    | block ? list_expr

// keys && values
keys_expr ::= ('keys' | 'values' ) keys_args
keys_args ::=
    '(' (hash | array) ')'
    | (hash | array)

// grep
grep_expr ::= ('grep' | 'map' ) block list_expr


array ::=
    array_safe '[' expr ']'              // array slice
    | array_safe '{' expr '}'              // hash slice
    | array_safe
    | '(' ')'                       // empty array

private array_safe ::=
    PERL_SIGIL_ARRAY '{' expr '}'   // scalar dereference
    | PERL_SIGIL_ARRAY scalar       // scalar dereference
    | PERL_ARRAY                    // array as is

hash ::=
    PERL_SIGIL_HASH '{' expr '}'   // hash dereference w braces
    | PERL_SIGIL_HASH scalar       // scalar dereference wo braces
    | PERL_HASH                    // hash as is

scalar ::=
    shift_expr                        // shift expression
    | scalar_safe '->'? '[' expr ']'      // array element
    | scalar_safe '->'? '{' expr '}'    // hash element
    | '[' expr ? ']'                    // anonymous array
    | '{' expr ? '}'                    // anonymous hash
    | '(' expr ')'[expr]                // generated array element
    | scalar_safe                       // scalar or deref scalar


private string ::= string_quoted | string_unquoted | PERL_STRING_CONTENT | <<parseBarewordString>>
private string_quoted ::= ('qq' | 'qx' | 'q') ? PERL_QUOTE PERL_STRING_CONTENT PERL_QUOTE  // bareword string should be here
private string_unquoted ::= PERL_STRING_CONTENT

private scalar_safe ::=
//    PERL_SIGIL_SCALAR '{' PERL_BAREWORD '}'       // scalar dereference
    PERL_SIGIL_SCALAR '{' expr '}'       // scalar dereference
    | PERL_SCALAR                          // scalar as is
    | multiline_marker                  // deferred string
    | PERL_NUMBER                       // raw number
    | string                            // string
    | PERL_TAG
    | sub_block_anon
    | PERL_GLOB
    | '&' referencable_method

private referencable_method ::=
    perl_package_function
    | perl_function

perl_version ::= PERL_NUMBER_VERSION | PERL_NUMBER

private multiline_marker ::= '<<' (string | PERL_BAREWORD)

private variables ::= variable (',' variable ) *
private variable ::= PERL_SCALAR | PERL_ARRAY | PERL_HASH

// custom parsings
private perl_package ::= <<parseBarewordPackage>>
private perl_function ::= <<parseBarewordFunction>>
private perl_package_function ::= <<parsePackageFunctionCall>>
private perl_method_parent ::= scalar '->' <<parsePackageMethodSuper>>

//private package_bare ::= PERL_BAREWORD ( '::' PERL_BAREWORD ) *
// {   mixin="com.perl5.lang.perl.psi.impl.PerlNamedElementImpl"
//        implements="com.perl5.lang.perl.psi.PerlNamedElement"
//        methods=[getName setName getNameIdentifier]
//    }

