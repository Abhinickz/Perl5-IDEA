#!/usr/bin/perl
use v5.10;
use strict;
no strict 'refs';
use File::Find;
use B::Deparse;

File::Find::find( \&file_processor, @INC );

my @packages = ();
sub file_processor
{
    if ($File::Find::name =~ m{auto/(.+?)/([^/]+)(dll|so)$})
    {
        my $name = $1;
        $name =~ s{/+}{::}g;
        eval "require $name;";
        if (my $e = $@)
        {
            warn "Error loading $name: $e";
        }
    }
}

my $deparser = B::Deparse->new();
my %sub_map = ();

say "#";
say "#";
say "# DO NOT EDIT THIS FILE, IT'S AUTOGENERATED FROM XS MODULES AND WILL BE UPDATED AUTOMATICALLY";
say "#";
say "#";

foreach my $globname (sort @{get_typeglobs_snapshot()})
{
    next if $globname =~ /::bootstrap/;
    next if $globname =~ /[^\w\:_]/;

    if (*{$globname}{CODE})
    {
        my $deparsed = eval {$deparser->coderef2text( \&{$globname} )};
        if ($deparsed =~ /^(?:\(.*?\))?\s*;$/)
        {
            $globname =~ s/^:://;
            #            say "sub $globname$deparsed";
            $globname =~ /^(.+)::([^:]+)$/;
            my ($package, $sub) = ($1, $2);
            $sub_map{$package} //= [ ];
            push @{$sub_map{$package}}, $sub.$deparsed;
        }
    }
}

foreach my $package (sort keys %sub_map)
{

    say "package $package {";
    foreach my $sub_name (sort @{$sub_map{$package}})
    {
        say "sub $sub_name";
    }
    say "}\n";
}

sub get_typeglobs_snapshot
{
    my $namespace = shift // "";
    my $recursion_map = shift // { qw/::main/ };

    $namespace =~ s/::$//;

    return [ ] if (exists $recursion_map->{$namespace});
    $recursion_map->{$namespace} = 1;

    my $result = [ ];

    foreach my $name (keys %{"${namespace}::"})
    {
        my $canonical_name = "${namespace}::$name";
        if ($name =~ /::$/)
        {
            push @{$result}, @{get_typeglobs_snapshot( $canonical_name, $recursion_map )};
        }
        else
        {
            push @{$result}, $canonical_name;
        }
    }

    return $result;
}
